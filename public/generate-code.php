<?php
header('Content-Type: application/json');

// Database connection
require_once '../src/connect.php';

// Get parameters
$difficulty = $_GET['difficulty'] ?? 'medium';
$level = $_GET['level'] ?? 1;

// Code snippets database for different difficulty levels and types
$codeSnippets = [
    'easy' => [
        // 1-10 (original examples)
        [ 'code' => 'const name = "John";', 'description' => 'This line declares a constant variable called name and assigns it the string value "John". Constants in JavaScript cannot be reassigned after their initial value is set. This is useful for values that should remain unchanged throughout the program, such as configuration values, fixed names, or identifiers. Using const helps prevent accidental changes to important data and makes your code more predictable and easier to debug. In this example, the variable name will always hold the value "John" and cannot be changed later in the code.', 'purpose' => 'Store a fixed value.' ],
        [ 'code' => 'let age = 25;', 'description' => 'This line creates a variable named age using the let keyword and assigns it the value 25. The let keyword allows you to declare variables that can be updated later in your code, making it ideal for values that may change over time, such as counters, user input, or dynamic data. In this example, age starts at 25, but you can reassign it to a different value if needed. Using let instead of var is recommended in modern JavaScript because it provides block scope and helps avoid bugs related to variable hoisting.', 'purpose' => 'Track a value that may change.' ],
        [ 'code' => 'var greeting = "Hello";', 'description' => 'This line declares a variable named greeting using the var keyword and assigns it the string "Hello". The var keyword is the traditional way to declare variables in JavaScript, but it has function scope rather than block scope, which can sometimes lead to unexpected behavior. It is generally better to use let or const in modern code. Here, greeting can be reassigned to a new value later, and it is accessible throughout the function in which it is declared. This is useful for storing messages or other values that may be reused or updated.', 'purpose' => 'Store a message for reuse.' ],
        [ 'code' => 'console.log("Hello World");', 'description' => 'This line prints the string "Hello World" to the browser’s console. The console.log function is commonly used for debugging and displaying information during development. It helps you track the flow of your program, inspect variable values, and identify issues. Anything passed to console.log will appear in the console, making it a valuable tool for developers to understand what their code is doing at different stages of execution. This is often the first line of code written when learning a new programming language.', 'purpose' => 'Display information for debugging.' ],
        [ 'code' => 'if (x > 5) { return true; }', 'description' => 'This code checks if the variable x is greater than 5. If the condition is true, it returns true from the current function. The if statement is a fundamental control structure in JavaScript that allows you to execute code only when certain conditions are met. This is useful for decision-making, such as validating input, controlling program flow, or handling different scenarios based on variable values. In this example, the function will only return true if x is greater than 5; otherwise, it does nothing.', 'purpose' => 'Perform actions based on conditions.' ],
        [ 'code' => 'function add(a, b) { return a + b; }', 'description' => 'This code defines a function named add that takes two parameters, a and b, and returns their sum. Functions are reusable blocks of code that perform specific tasks. By defining a function, you can call it multiple times with different arguments, making your code more modular and easier to maintain. In this example, add can be used to add any two numbers together, and the result will be returned to the caller. Functions help organize code, reduce repetition, and improve readability.', 'purpose' => 'Encapsulate logic for addition.' ],
        [ 'code' => 'const arr = [1, 2, 3];', 'description' => 'This line creates an array named arr containing the numbers 1, 2, and 3. Arrays are ordered collections of values that can be accessed by their index. They are useful for storing lists of data, such as numbers, strings, or objects. In this example, arr[0] is 1, arr[1] is 2, and arr[2] is 3. Arrays can be modified by adding, removing, or updating elements, and they provide many built-in methods for manipulating data. Arrays are a core data structure in JavaScript.', 'purpose' => 'Store a list of values.' ],
        [ 'code' => 'const obj = { name: "test" };', 'description' => 'This line creates an object named obj with a single property called name, which has the value "test". Objects in JavaScript are collections of key-value pairs and are used to represent structured data. You can add, remove, or update properties on objects, making them flexible for storing related information. In this example, obj.name will return "test". Objects are widely used for representing real-world entities, configurations, and more complex data structures.', 'purpose' => 'Group related data.' ],
        [ 'code' => 'for (let i = 0; i < 10; i++) {}', 'description' => 'This is a for loop that runs 10 times, with the variable i starting at 0 and incrementing by 1 each time until it reaches 9. For loops are used to repeat a block of code a specific number of times, making them ideal for iterating over arrays, performing repeated calculations, or automating repetitive tasks. In this example, the loop body is empty, but you can add any code you want to execute on each iteration. The variable i is only accessible inside the loop.', 'purpose' => 'Repeat code a specific number of times.' ],
        [ 'code' => 'const result = x + y;', 'description' => 'This line declares a constant variable called result and assigns it the sum of x and y. This is a common pattern for storing the outcome of a calculation or operation. By using const, you ensure that result cannot be reassigned, which helps prevent accidental changes. This approach is useful for keeping your code clear and making it easier to track how values are derived. The result variable can then be used elsewhere in your program as needed.', 'purpose' => 'Store calculation results.' ],
        // 11-100 (new easy examples)
        [ 'code' => 'let score = 0;', 'description' => 'This line declares a variable named score using let and initializes it to 0. This is a common pattern for setting up counters or accumulators in games, loops, or any scenario where you need to keep track of a running total or progress. By initializing the variable to zero, you ensure that it starts from a known value, which is important for accurate calculations and logic. Using let allows you to update the score as the game or process continues, reflecting changes in state or user actions.', 'purpose' => 'Initialize a counter.' ],
        [ 'code' => 'const PI = 3.14;', 'description' => 'This line declares a constant named PI and assigns it the value 3.14, which is a common approximation of the mathematical constant π (pi). Using const ensures that the value cannot be changed later in the code, which is important for mathematical constants that should remain fixed. This pattern is useful in calculations involving circles, geometry, or any formulas where pi is required. Defining such constants at the top of your code improves readability and maintainability.', 'purpose' => 'Store a mathematical constant.' ],
        [ 'code' => 'let isActive = true;', 'description' => 'This line creates a variable named isActive and sets it to true. Boolean variables like this are often used to track the state of an object, feature, or process, such as whether a user is logged in, a game is running, or a feature is enabled. Using descriptive names and initializing state variables helps make your code more understandable and easier to debug, especially as your application grows in complexity.', 'purpose' => 'Track a true/false state.' ],
        [ 'code' => 'let message = "Welcome!";', 'description' => 'This line declares a variable named message and assigns it the string "Welcome!". Storing messages in variables allows you to reuse and update them easily, which is especially useful in user interfaces, notifications, or prompts. By keeping text in variables, you can also support localization, customization, and dynamic content generation, making your code more flexible and user-friendly.', 'purpose' => 'Store a welcome message.' ],
        [ 'code' => 'let total = price * quantity;', 'description' => 'This line multiplies the values of price and quantity and stores the result in a variable named total. This is a typical operation in shopping carts, billing systems, or any context where you need to calculate the total cost or amount based on unit price and quantity. Assigning the result to a variable allows you to use it in further calculations, display it to the user, or store it for later processing.', 'purpose' => 'Calculate a product.' ],
        [ 'code' => 'let diff = a - b;', 'description' => 'This line subtracts the value of b from a and assigns the result to a variable named diff. Calculating differences is a fundamental operation in programming, used in contexts such as measuring changes, comparing values, or determining distances. Storing the result in a variable makes it easy to use the difference in subsequent logic, display it, or perform additional calculations.', 'purpose' => 'Calculate a difference.' ],
        [ 'code' => 'let quotient = a / b;', 'description' => 'This line divides the value of a by b and stores the result in a variable named quotient. Division is a basic arithmetic operation used in many applications, such as calculating averages, rates, or proportions. By assigning the result to a variable, you can reuse it in further calculations, display it to users, or use it in conditional logic to make decisions based on the computed value.', 'purpose' => 'Calculate a quotient.' ],
        [ 'code' => 'let remainder = a % b;', 'description' => 'This line calculates the remainder when a is divided by b using the modulo operator (%) and stores it in a variable named remainder. The modulo operation is useful for tasks like determining if a number is even or odd, cycling through values, or implementing periodic behavior. Storing the result allows you to use it in further logic, such as conditional statements or loops.', 'purpose' => 'Find a remainder.' ],
        [ 'code' => 'let doubled = num * 2;', 'description' => 'This line multiplies the value of num by 2 and assigns the result to a variable named doubled. Doubling a value is a common operation in programming, used in scenarios such as scaling, adjusting quantities, or applying mathematical transformations. By storing the result in a variable, you can use it in subsequent calculations, display it, or make decisions based on the new value.', 'purpose' => 'Double a value.' ],
        [ 'code' => 'let half = num / 2;', 'description' => 'This line divides the value of num by 2 and stores the result in a variable named half. Halving a value is useful in many contexts, such as splitting resources, calculating averages, or implementing binary search algorithms. Assigning the result to a variable makes it easy to use the halved value in further logic, display it, or perform additional operations.', 'purpose' => 'Halve a value.' ],
        [ 'code' => 'let nameLength = name.length;', 'description' => 'This line gets the length of the string stored in the variable name and assigns it to a new variable nameLength. The length property is a common way to determine the size of a string in JavaScript, returning the number of code units in the string. This information is useful for validating input, allocating resources, or controlling program flow based on string size. By storing the length in a variable, you can easily use it in conditions, loops, or calculations.', 'purpose' => 'Find string length.' ],
        [ 'code' => 'let upper = text.toUpperCase();', 'description' => 'This line converts the string in the variable text to uppercase letters and assigns the result to a new variable upper. The toUpperCase method is useful for standardizing text, making comparisons case-insensitive, or formatting output. By storing the uppercase version in a variable, you can use it for display, logging, or further processing where consistent casing is required. This operation does not change the original string, as strings are immutable in JavaScript.', 'purpose' => 'Change string case.' ],
        [ 'code' => 'let lower = text.toLowerCase();', 'description' => 'This line converts the string in the variable text to lowercase letters and assigns the result to a new variable lower. The toLowerCase method is helpful for normalizing text, ensuring consistent casing for comparisons, or preparing data for storage or transmission. By keeping the original string intact and creating a lowercase version, you can perform case-sensitive operations or display the text in a uniform format. This is particularly useful in search functionalities, data normalization, and user interface display.', 'purpose' => 'Change string case.' ],
        [ 'code' => 'let firstChar = str[0];', 'description' => 'This line accesses the first character of the string str using bracket notation and assigns it to a variable firstChar. In JavaScript, strings are zero-indexed, meaning the first character is at position 0. This operation is commonly used to retrieve specific characters from a string, such as the first letter of a name, the first digit of a number, or any scenario where you need to examine or use individual characters. By storing the result in a variable, you can easily use or manipulate this character in your code.', 'purpose' => 'Access a character in a string.' ],
        [ 'code' => 'let lastChar = str[str.length - 1];', 'description' => 'This line accesses the last character of the string str by using its length property to calculate the last index and assigns it to a variable lastChar. This is a common technique to retrieve the final character in a string, such as getting the last letter of a word, the last digit of a number, or any case where the end of the string is significant. By storing this character in a variable, you can use it for validation, formatting, or any logic that depends on the content or structure of the string.', 'purpose' => 'Access the last character.' ],
        [ 'code' => 'let arrLength = arr.length;', 'description' => 'This line gets the number of elements in the array arr using the length property and assigns it to a variable arrLength. Knowing the length of an array is essential for iterating over it, allocating resources, or performing operations that depend on the number of items, such as averaging numbers, concatenating strings, or validating data. By storing the length in a variable, you can efficiently use it in loops, conditions, or calculations without having to access the length property multiple times, which can be less efficient.', 'purpose' => 'Find array length.' ],
        [ 'code' => 'arr.push(4);', 'description' => 'This line adds the value 4 to the end of the array arr using the push method. The push method is a common way to add new items to an array in JavaScript, modifying the original array by appending the new element. This operation is useful for building lists, queues, or any data structure that requires adding elements to the end. By using push, you can easily grow your array as needed, based on user input, calculations, or other dynamic data sources. After this operation, the length of the array will increase by one.', 'purpose' => 'Add an element to an array.' ],
        [ 'code' => 'arr.pop();', 'description' => 'This line removes the last element from the array arr using the pop method. The pop method is a standard way to remove items from the end of an array in JavaScript, altering the original array by removing the last element. This operation is commonly used to decrease the size of an array, such as when processing data in chunks, implementing undo features, or managing dynamic lists. The removed element can be used or stored if needed, as pop returns the element that was removed. If the array is empty, pop will return undefined and the array will remain unchanged.', 'purpose' => 'Remove an element from an array.' ],
        [ 'code' => 'arr.unshift(0);', 'description' => 'This line adds the value 0 to the beginning of the array arr using the unshift method. The unshift method is used to prepend new items to an array in JavaScript, modifying the original array by adding the new element at the start. This operation is useful for implementing stacks, priority queues, or any data structure that requires adding elements to the front. After this operation, the length of the array will increase by one, and all existing elements will have their indices incremented by one. If you need to add multiple elements, you can pass them as additional arguments to unshift, and they will be added in order.', 'purpose' => 'Add an element to the start.' ],
        [ 'code' => 'arr.shift();', 'description' => 'This line removes the first element from the array arr using the shift method. The shift method is a standard way to remove items from the beginning of an array in JavaScript, altering the original array by removing the first element. This operation is commonly used to process data in FIFO (First In, First Out) order, such as with queues or when you need to remove a specific item that was added earlier. The removed element can be used or stored if needed, as shift returns the element that was removed. If the array is empty, shift will return undefined and the array will remain unchanged.', 'purpose' => 'Remove the first element.' ],
        [ 'code' => 'let index = arr.indexOf(2);', 'description' => 'This line finds the index of the first occurrence of the value 2 in the array arr using the indexOf method and assigns it to a variable index. The indexOf method returns the index of the element if found, or -1 if the element is not present in the array. This operation is useful for searching elements in an array, validating data, or implementing features like autocomplete, where you need to check if a value already exists in a list. By storing the index in a variable, you can easily use it in conditions, loops, or any logic that depends on the position of the element in the array.', 'purpose' => 'Search for an element.' ],
        [ 'code' => 'let found = arr.includes(3);', 'description' => 'This line checks if the value 3 is present in the array arr using the includes method and assigns the result (true or false) to a variable found. The includes method is a convenient way to determine the existence of an element in an array, returning true if the element is found and false otherwise. This operation is useful for validation, conditional logic, or implementing features like "favorites" or "bans", where you need to check if an item is already in the list. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the presence or absence of the element.', 'purpose' => 'Check for existence in array.' ],
        [ 'code' => 'obj.age = 30;', 'description' => 'This line sets the age property of the object obj to the value 30. If the age property does not exist, it will be created. This is a common operation for updating object properties, which is essential for managing state, configuration, or any data encapsulated in objects. By directly assigning a value to an object property, you can easily modify the state or characteristics of an object instance. This operation does not require any special syntax or methods, just the dot notation or bracket notation for the property you want to set. After this operation, obj will have an age property with the value 30, which can be used in calculations, displayed to users, or sent to a server.', 'purpose' => 'Modify an object property.' ],
        [ 'code' => 'delete obj.name;', 'description' => 'This line deletes the name property from the object obj. If the property exists, it will be removed, and its value will be discarded. This operation is useful for cleaning up objects, removing unnecessary or sensitive information, or implementing features like "forgetting" a user preference or state. After this operation, the name property will no longer be accessible on the obj object, and any attempt to read it will return undefined. This operation does not affect other properties of the object, which will remain intact. If you need to delete multiple properties, you can call delete multiple times, once for each property you want to remove.', 'purpose' => 'Remove a property from an object.' ],
        [ 'code' => 'let type = typeof value;', 'description' => 'This line uses the typeof operator to determine the data type of the variable value and assigns the result to a new variable type. The typeof operator returns a string indicating the type of the unevaluated operand, which can be useful for debugging, validation, or implementing dynamic behavior based on data types. Common results of the typeof operator are "undefined", "boolean", "number", "string", "object", and "function". By storing the result in a variable, you can easily use it in conditions, logs, or any logic that depends on the type of the value. This is particularly useful in JavaScript, where variables are dynamically typed and the type of a value can change at runtime.', 'purpose' => 'Check a variable type.' ],
        [ 'code' => 'let isArray = Array.isArray(arr);', 'description' => 'This line uses the Array.isArray method to check if the variable arr is an array and assigns the result (true or false) to a new variable isArray. This method is the standard way to determine if a value is an array in JavaScript, as arrays are a special type of object. Knowing whether a variable is an array is important for validating data, controlling program flow, or applying array-specific methods and properties. By storing the result in a variable, you can easily use it in your code to handle arrays and non-arrays differently if needed. This is especially useful in functions or methods that can receive different types of arguments.', 'purpose' => 'Test if a variable is an array.' ],
        [ 'code' => 'let notFound = arr.indexOf(99);', 'description' => 'This line attempts to find the index of the value 99 in the array arr using the indexOf method and assigns the result to a variable notFound. If 99 is not present in the array, indexOf will return -1, which is a common convention in programming to indicate "not found". This operation is useful for searching elements in an array, validating data, or implementing features like autocomplete, where you need to check if a value already exists in a list. By storing the result in a variable, you can easily use it in conditions, loops, or any logic that depends on the position of the element in the array. If the value is not found, you can use the -1 result to trigger alternative logic, such as adding the value to the array, notifying the user, or selecting a default value.', 'purpose' => 'Handle missing elements.' ],
        [ 'code' => 'let emptyArr = [];', 'description' => 'This line creates a new empty array and assigns it to a variable emptyArr. Initializing an empty array is a common practice when you plan to store a list of items, such as numbers, strings, or objects, but do not have the items available at the moment of declaration. By starting with an empty array, you can later add items to it using methods like push, unshift, or splice, depending on where you want to add the items. This operation is useful for setting up data structures, collecting results, or managing dynamic lists that will be populated or modified over time. After this operation, emptyArr is an array with a length of 0, and any array methods or properties can be used on it.', 'purpose' => 'Initialize an empty list.' ],
        [ 'code' => 'let emptyObj = {};', 'description' => 'This line creates a new empty object and assigns it to a variable emptyObj. Initializing an empty object is a common practice when you plan to store key-value pairs, but do not have the data available at the moment of declaration. By starting with an empty object, you can later add properties to it using dot notation or bracket notation, depending on your preference or the requirements of your code. This operation is useful for setting up data structures, configuring options, or managing dynamic data that will be populated or modified over time. After this operation, emptyObj is an object with no properties, and any object methods or properties can be used on it.', 'purpose' => 'Initialize an empty object.' ],
        [ 'code' => 'let bool = false;', 'description' => 'This line declares a variable named bool and initializes it to false. Boolean variables like this are often used to represent binary states, such as on/off, true/false, or yes/no. Using descriptive names for boolean variables helps make your code more readable and understandable, as it becomes clear what state or condition the variable is tracking. By initializing the variable to false, you establish a default state that can be changed later in the code based on user actions, calculations, or other logic. This pattern is common in flags, toggles, and any scenario where a binary choice or state is needed.', 'purpose' => 'Track a false state.' ],
        [ 'code' => 'let sum = 1 + 2 + 3;', 'description' => 'This line adds the numbers 1, 2, and 3 together using the + operator and assigns the result to a variable named sum. The + operator is used for both numeric addition and string concatenation in JavaScript, but in this case, it is used to perform arithmetic addition. This operation is useful for calculating totals, performing mathematical operations, or any scenario where you need to combine values. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the computed value. This pattern is common in financial calculations, data processing, and any context where numbers are used.', 'purpose' => 'Sum multiple values.' ],
        [ 'code' => 'let product = 2 * 3 * 4;', 'description' => 'This line multiplies the numbers 2, 3, and 4 together using the * operator and assigns the result to a variable named product. The * operator is used to perform arithmetic multiplication in JavaScript. This operation is useful for calculating totals, performing mathematical operations, or any scenario where you need to combine values multiplicatively. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the computed value. This pattern is common in financial calculations, data processing, and any context where numbers are used. The result of this multiplication is 24, which is the product of the three numbers.', 'purpose' => 'Multiply several values.' ],
        [ 'code' => 'let average = (a + b) / 2;', 'description' => 'This line calculates the average of the values a and b by adding them together and dividing by 2, then assigns the result to a variable named average. This is a common formula for calculating the mean value of two numbers. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the computed average. This pattern is useful in statistical calculations, data analysis, and any context where you need to find the central tendency of a set of values. If you need to calculate the average of more than two numbers, you can extend this pattern by adding more values and adjusting the divisor accordingly.', 'purpose' => 'Find an average.' ],
        [ 'code' => 'let min = Math.min(1, 2, 3);', 'description' => 'This line uses the Math.min function to find the minimum value among the numbers 1, 2, and 3, and assigns the result to a variable named min. The Math.min function returns the smallest of zero or more numbers given as input parameters. This operation is useful for finding the lowest value in a set of numbers, which can be important in calculations, data analysis, or any scenario where you need to determine the minimum value. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the computed minimum. This pattern is common in statistical calculations, data processing, and any context where you need to find the smallest number in a set.', 'purpose' => 'Get the smallest number.' ],
        [ 'code' => 'let max = Math.max(1, 2, 3);', 'description' => 'This line uses the Math.max function to find the maximum value among the numbers 1, 2, and 3, and assigns the result to a variable named max. The Math.max function returns the largest of zero or more numbers given as input parameters. This operation is useful for finding the highest value in a set of numbers, which can be important in calculations, data analysis, or any scenario where you need to determine the maximum value. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the computed maximum. This pattern is common in statistical calculations, data processing, and any context where you need to find the largest number in a set.', 'purpose' => 'Get the largest number.' ],
        [ 'code' => 'let random = Math.random();', 'description' => 'This line generates a random floating-point number between 0 (inclusive) and 1 (exclusive) using the Math.random function and assigns the result to a variable named random. The Math.random function is commonly used to create random values for simulations, games, testing, or any scenario where unpredictability is desired. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the generated random value. This pattern is useful in scenarios like generating random colors, selecting random items from a list, or creating noise functions for procedural generation. If you need a random number in a different range or with different characteristics, you can apply mathematical transformations to the result of Math.random, such as scaling, shifting, or rounding.', 'purpose' => 'Get a random value.' ],
        [ 'code' => 'let rounded = Math.round(2.7);', 'description' => 'This line rounds the number 2.7 to the nearest integer using the Math.round function and assigns the result to a variable named rounded. The Math.round function is useful for converting floating-point numbers to whole numbers, which is important in scenarios where you need discrete values, such as counting items, indexing arrays, or displaying rounded values to users. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the rounded value. This pattern is common in financial calculations, data processing, and any context where numbers are used. The result of this rounding operation is 3, as 2.7 is closer to 3 than to 2.', 'purpose' => 'Round a number.' ],
        [ 'code' => 'let floored = Math.floor(2.7);', 'description' => 'This line rounds the number 2.7 down to the nearest integer using the Math.floor function and assigns the result to a variable named floored. The Math.floor function is useful for converting floating-point numbers to whole numbers, always rounding down towards negative infinity. This is important in scenarios where you need discrete values, such as counting items, indexing arrays, or implementing pagination. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the floored value. This pattern is common in financial calculations, data processing, and any context where numbers are used. The result of this flooring operation is 2, as Math.floor always rounds down.', 'purpose' => 'Floor a number.' ],
        [ 'code' => 'let ceiled = Math.ceil(2.1);', 'description' => 'This line rounds the number 2.1 up to the nearest integer using the Math.ceil function and assigns the result to a variable named ceiled. The Math.ceil function is useful for converting floating-point numbers to whole numbers, always rounding up towards positive infinity. This is important in scenarios where you need discrete values, such as counting items, indexing arrays, or implementing pricing strategies. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the ceiled value. This pattern is common in financial calculations, data processing, and any context where numbers are used. The result of this ceiling operation is 3, as Math.ceil always rounds up.', 'purpose' => 'Ceil a number.' ],
        [ 'code' => 'let absVal = Math.abs(-5);', 'description' => 'This line calculates the absolute value of -5 using the Math.abs function and assigns the result to a variable named absVal. The Math.abs function returns the non-negative value of a number, effectively removing any negative sign. This operation is useful in scenarios where you need to ensure a value is positive, such as when calculating distances, magnitudes, or any context where negative values do not make sense. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the absolute value. This pattern is common in mathematical computations, data processing, and any context where values can be negative but need to be treated as positive for further processing.', 'purpose' => 'Remove a negative sign.' ],
        [ 'code' => 'let strNum = String(123);', 'description' => 'This line converts the number 123 to a string using the String function and assigns the result to a variable named strNum. The String function is a common way to explicitly convert values to strings in JavaScript. This operation is useful in scenarios where you need to concatenate values, display numbers as text, or ensure consistent data types. By storing the result in a variable, you can use it in further string operations, display it to users, or send it as part of a text-based data format like JSON or XML. This pattern is common in data formatting, user interface development, and any context where values need to be represented as text. The resulting string will be "123", and you can verify its type using the typeof operator.', 'purpose' => 'Change a number to a string.' ],
        [ 'code' => 'let numStr = Number("456");', 'description' => 'This line converts the string "456" to a number using the Number function and assigns the result to a variable named numStr. The Number function is a standard way to explicitly convert values to numbers in JavaScript. This operation is useful in scenarios where you need to perform mathematical calculations, comparisons, or any context where numeric data types are required. By storing the result in a variable, you can use it in further calculations, display it, or make decisions based on the numeric value. This pattern is common in data processing, form handling, and any context where user input or text data needs to be converted to numbers for computation. The resulting number will be 456, and you can verify its type using the typeof operator.', 'purpose' => 'Change a string to a number.' ],
        [ 'code' => 'let parsed = parseInt("42");', 'description' => 'This line parses an integer from the string "42" using the parseInt function and assigns the result to a variable named parsed. The parseInt function converts its first argument to a string, parses it, and returns an integer or NaN. This operation is useful for extracting whole numbers from strings, such as when processing user input, reading data from files, or any context where numbers are embedded in text. By storing the result in a variable, you can use it in further calculations, display it, or validate it. This pattern is common in data parsing, form handling, and any context where numeric data is represented as text. The resulting value will be 42, and you can verify its type using the typeof operator. If the string cannot be converted to a valid integer, parseInt will return NaN, which stands for "Not-a-Number" and is used to represent an unrepresentable or undefined numerical value.', 'purpose' => 'Extract a number from text.' ],
        [ 'code' => 'let parsedFloat = parseFloat("3.14");', 'description' => 'This line parses a floating-point number from the string "3.14" using the parseFloat function and assigns the result to a variable named parsedFloat. The parseFloat function converts its first argument to a string, parses it, and returns a floating-point number or NaN. This operation is useful for extracting decimal numbers from strings, such as when processing user input, reading data from files, or any context where numbers with fractions are represented as text. By storing the result in a variable, you can use it in further calculations, display it, or validate it. This pattern is common in data parsing, form handling, and any context where numeric data with decimals is represented as text. The resulting value will be 3.14, and you can verify its type using the typeof operator. If the string cannot be converted to a valid floating-point number, parseFloat will return NaN, which stands for "Not-a-Number" and is used to represent an unrepresentable or undefined numerical value.', 'purpose' => 'Extract a decimal number.' ],
        [ 'code' => 'let fixed = (3.14159).toFixed(2);', 'description' => 'This line formats the number 3.14159 to 2 decimal places using the toFixed method and assigns the result to a variable named fixed. The toFixed method converts a number to a string, rounding it to a specified number of decimal places. This operation is useful for controlling the display of numbers, such as in financial applications, where you need to show a consistent number of decimal places. By storing the result in a variable, you can use it in further calculations, display it, or send it as part of a text-based data format. This pattern is common in data formatting, reporting, and any context where numeric values need to be presented with a fixed number of decimal places. The resulting string will be "3.14", and you can verify its type using the typeof operator. Note that toFixed returns a string, not a number, so if you need to perform further calculations, you may need to convert the result back to a number using parseFloat or a similar method.', 'purpose' => 'Format a number.' ],
        [ 'code' => 'let joined = arr.join(",");', 'description' => 'This line joins the elements of the array arr into a single string, separated by commas, using the join method and assigns the result to a variable named joined. The join method is useful for creating a string representation of an array, such as when generating CSV data, displaying a list of items, or any context where you need a delimited string. By storing the result in a variable, you can use it in further processing, display it, or transmit it as text. This pattern is common in data serialization, reporting, and any context where array data needs to be converted to a string format. The resulting string will contain all array elements concatenated together, separated by commas. If the array is empty, the result will be an empty string. You can also use other characters or strings as separators by passing them as arguments to the join method.', 'purpose' => 'Create a comma-separated list.' ],
        [ 'code' => 'let split = str.split(",");', 'description' => 'This line splits the string str into an array of substrings using the split method and a comma as the delimiter, and assigns the result to a variable named split. The split method is useful for parsing delimited data, such as CSV files, query parameters, or any context where you need to extract individual elements from a string. By storing the result in a variable, you can use it in further processing, such as validating, transforming, or analyzing the data. This pattern is common in data parsing, form handling, and any context where text data needs to be converted to an array format. The resulting array will contain all substrings separated by commas in the original string. If the string does not contain any commas, the resulting array will have a length of 1, containing the entire string. You can also use regular expressions as delimiters by passing them as arguments to the split method.', 'purpose' => 'Break a string into parts.' ],
        [ 'code' => 'let trimmed = str.trim();', 'description' => 'This line removes whitespace from both ends of the string str using the trim method and assigns the result to a variable named trimmed. The trim method is useful for cleaning up strings by removing unnecessary spaces, tabs, or other whitespace characters that may cause issues in data processing, validation, or display. By storing the result in a variable, you can use it in further processing, such as comparing, storing, or displaying the cleaned-up string. This pattern is common in data cleaning, form handling, and any context where string data needs to be normalized or validated. The resulting string will have no leading or trailing whitespace, but any whitespace characters between words or elements will be preserved. If you need to remove whitespace from only one end of the string, you can use the trimStart or trimEnd methods instead, which are also available on string objects.', 'purpose' => 'Clean up a string.' ],
        [ 'code' => 'let replaced = str.replace("a", "b");', 'description' => 'This line replaces the first occurrence of the character "a" with "b" in the string str. The replace method returns a new string with the replacement made, leaving the original string unchanged. This operation is useful for modifying strings, such as correcting errors, updating values, or formatting output. By storing the result in a variable, you can use the modified string in further processing, display it, or store it. If you need to replace all occurrences of a character or substring, you can use a regular expression with the global flag g, like this: str.replace(/a/g, "b").', 'purpose' => 'Change part of a string.' ],
        [ 'code' => 'let includes = str.includes("test");', 'description' => 'This line checks if the string str contains the substring "test" and assigns the result (true or false) to a variable named includes. The includes method is a convenient way to perform substring searches within strings, returning true if the substring is found and false otherwise. This operation is useful for validation, conditional logic, or implementing features like "search", where you need to check if a certain pattern exists in the text. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the presence or absence of the substring.', 'purpose' => 'Search for a substring.' ],
        [ 'code' => 'let slice = arr.slice(1, 3);', 'description' => 'This line extracts a portion of the array arr from index 1 to index 3 (exclusive) using the slice method and assigns the result to a variable named slice. The slice method returns a new array containing the selected elements, without modifying the original array. This operation is useful for creating subarrays, copying parts of an array, or extracting elements based on their position. By storing the result in a variable, you can work with the sliced portion of the array separately, such as processing, displaying, or further manipulating the data. In this example, slice will contain the elements at index 1 and 2 of arr.', 'purpose' => 'Extract part of an array.' ],
        [ 'code' => 'let concat = arr1.concat(arr2);', 'description' => 'This line concatenates two arrays, arr1 and arr2, into a new array using the concat method and assigns the result to a variable named concat. The concat method is used to combine two or more arrays in JavaScript, returning a new array that contains all the elements from the joined arrays. This operation is useful for merging data, combining results, or building new arrays from existing ones. By storing the result in a variable, you can work with the combined array as a single entity, such as processing, displaying, or further manipulating the data. The original arrays, arr1 and arr2, remain unchanged. If you need to concatenate more than two arrays, you can pass them as additional arguments to the concat method, or use the spread operator: [...arr1, ...arr2].', 'purpose' => 'Merge arrays.' ],
        [ 'code' => 'let reversed = arr.reverse();', 'description' => 'This line reverses the order of the elements in the array arr in place using the reverse method and assigns the result to a variable named reversed. The reverse method modifies the original array by reversing the order of its elements, so the first element becomes the last, and the last becomes the first. This operation is useful for tasks like undoing actions, displaying data in reverse order, or simply reversing a sequence. By storing the result in a variable, you can work with the reversed array, such as processing, displaying, or further manipulating the data. The length of the array remains the same, but the order of the elements is inverted. If you need to reverse a portion of an array, you can use the slice method to create a subarray and then reverse it, like this: arr.slice().reverse().', 'purpose' => 'Reverse an array.' ],
        [ 'code' => 'let sorted = arr.sort();', 'description' => 'This line sorts the elements of the array arr in ascending order using the sort method and assigns the result to a variable named sorted. The sort method modifies the original array by sorting its elements according to the Unicode code points of the strings. This operation is useful for organizing data, making it easier to read, analyze, or process. By storing the result in a variable, you can work with the sorted array, such as displaying or further manipulating the data. The sort method accepts an optional compare function that you can use to customize the sort order, such as sorting numbers numerically or sorting strings by length. If the compare function is not provided, the elements are sorted as strings in ascending order.', 'purpose' => 'Sort an array.' ],
        [ 'code' => 'let boolStr = bool.toString();', 'description' => 'This line converts the boolean value of the variable bool to a string using the toString method and assigns the result to a variable named boolStr. The toString method is a common way to explicitly convert values to strings in JavaScript. This operation is useful in scenarios where you need to concatenate values, display boolean values as text, or ensure consistent data types. By storing the result in a variable, you can use it in further string operations, display it to users, or send it as part of a text-based data format like JSON or XML. This pattern is common in data formatting, user interface development, and any context where boolean values need to be represented as text. The resulting string will be "true" or "false", depending on the value of bool, and you can verify its type using the typeof operator.', 'purpose' => 'Stringify a boolean.' ],
        [ 'code' => 'let charCode = str.charCodeAt(0);', 'description' => 'This line gets the Unicode character code of the first character in the string str using the charCodeAt method and assigns the result to a variable named charCode. The charCodeAt method returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index. This operation is useful for tasks like encoding, decoding, or manipulating individual characters in a string. By storing the result in a variable, you can use it in further calculations, comparisons, or any logic that depends on the character code. This pattern is common in text processing, cryptography, and any context where character encoding is relevant. If you need to get the character code of a different character, you can pass the index of that character to the charCodeAt method, like this: str.charCodeAt(index).', 'purpose' => 'Find a character code.' ],
        [ 'code' => 'let fromChar = String.fromCharCode(65);', 'description' => 'This line converts the Unicode code point 65 to its corresponding character using the fromCharCode method of the String object and assigns the result to a variable named fromChar. The fromCharCode method is useful for decoding or converting numeric character references to their string representation. By storing the result in a variable, you can use the character in further processing, such as displaying it, concatenating it with other strings, or using it in calculations. This pattern is common in text processing, data formatting, and any context where character encoding is relevant. The resulting character will be "A", as 65 is the code point for "A" in the Unicode character set. If you need to convert multiple code points to characters, you can pass them as separate arguments to the fromCharCode method, like this: String.fromCharCode(65, 66, 67).', 'purpose' => 'Convert code to character.' ],
        [ 'code' => 'let now = Date.now();', 'description' => 'This line gets the current timestamp in milliseconds since January 1, 1970, 00:00:00 UTC using the now method of the Date object and assigns the result to a variable named now. The now method returns a number that represents the number of milliseconds elapsed since the Unix epoch. This operation is useful for tasks like measuring time intervals, scheduling events, or timestamping data. By storing the result in a variable, you can use the timestamp in further calculations, comparisons, or any logic that depends on the current time. This pattern is common in logging, performance measurement, and any context where you need to work with time values. If you need to create a Date object from the timestamp, you can pass the timestamp to the Date constructor, like this: new Date(timestamp).', 'purpose' => 'Get the current time.' ],
        [ 'code' => 'let today = new Date();', 'description' => 'This line creates a new Date object representing the current date and time using the Date constructor and assigns it to a variable named today. The Date object in JavaScript represents a single moment in time in a platform-independent format. This operation is useful for tasks like displaying the current date, calculating date differences, or scheduling events. By storing the result in a variable, you can use the Date object in further calculations, formatting, or any logic that depends on the current date and time. This pattern is common in scheduling, logging, and any context where you need to work with date and time values. If you need to create a Date object for a specific date and time, you can pass the date and time components to the Date constructor, like this: new Date(year, month, day, hour, minute, second).', 'purpose' => 'Get the current date.' ],
        [ 'code' => 'let year = today.getFullYear();', 'description' => 'This line gets the year of the Date object today using the getFullYear method and assigns the result to a variable named year. The getFullYear method returns the year of the specified date according to local time, as a four-digit number. This operation is useful for tasks like displaying the year, calculating age, or scheduling events. By storing the result in a variable, you can use the year in further calculations, comparisons, or any logic that depends on the year value. This pattern is common in scheduling, logging, and any context where you need to work with date and time values. If you need to get the year in UTC, you can use the getUTCFullYear method instead, like this: today.getUTCFullYear().', 'purpose' => 'Extract the year.' ],
        [ 'code' => 'let month = today.getMonth();', 'description' => 'This line gets the month of the Date object today using the getMonth method and assigns the result to a variable named month. The getMonth method returns the month of the specified date according to local time, as a zero-based value (0 for January, 1 for February, etc.). This operation is useful for tasks like displaying the month, calculating expiration dates, or scheduling events. By storing the result in a variable, you can use the month in further calculations, comparisons, or any logic that depends on the month value. This pattern is common in scheduling, logging, and any context where you need to work with date and time values. If you need to get the month in UTC, you can use the getUTCMonth method instead, like this: today.getUTCMonth().', 'purpose' => 'Extract the month.' ],
        [ 'code' => 'let day = today.getDate();', 'description' => 'This line gets the day of the month of the Date object today using the getDate method and assigns the result to a variable named day. The getDate method returns the day of the month for the specified date according to local time, as a number between 1 and 31. This operation is useful for tasks like displaying the day, calculating due dates, or scheduling events. By storing the result in a variable, you can use the day in further calculations, comparisons, or any logic that depends on the day value. This pattern is common in scheduling, logging, and any context where you need to work with date and time values. If you need to get the day in UTC, you can use the getUTCDate method instead, like this: today.getUTCDate().', 'purpose' => 'Extract the day.' ],
        [ 'code' => 'let hours = today.getHours();', 'description' => 'This line gets the hour of the Date object today using the getHours method and assigns the result to a variable named hours. The getHours method returns the hour for the specified date according to local time, as a number between 0 and 23. This operation is useful for tasks like displaying the time, scheduling events, or calculating time differences. By storing the result in a variable, you can use the hours in further calculations, comparisons, or any logic that depends on the hour value. This pattern is common in scheduling, logging, and any context where you need to work with date and time values. If you need to get the hour in UTC, you can use the getUTCHours method instead, like this: today.getUTCHours().', 'purpose' => 'Extract the hour.' ],
        [ 'code' => 'let minutes = today.getMinutes();', 'description' => 'This line gets the minutes of the Date object today using the getMinutes method and assigns the result to a variable named minutes. The getMinutes method returns the minutes for the specified date according to local time, as a number between 0 and 59. This operation is useful for tasks like displaying the time, scheduling events, or calculating time differences. By storing the result in a variable, you can use the minutes in further calculations, comparisons, or any logic that depends on the minute value. This pattern is common in scheduling, logging, and any context where you need to work with date and time values. If you need to get the minutes in UTC, you can use the getUTCMinutes method instead, like this: today.getUTCMinutes().', 'purpose' => 'Extract the minutes.' ],
        [ 'code' => 'let seconds = today.getSeconds();', 'description' => 'This line gets the seconds of the Date object today using the getSeconds method and assigns the result to a variable named seconds. The getSeconds method returns the seconds for the specified date according to local time, as a number between 0 and 59. This operation is useful for tasks like displaying the time, scheduling events, or calculating time differences. By storing the result in a variable, you can use the seconds in further calculations, comparisons, or any logic that depends on the second value. This pattern is common in scheduling, logging, and any context where you need to work with date and time values. If you need to get the seconds in UTC, you can use the getUTCSeconds method instead, like this: today.getUTCSeconds().', 'purpose' => 'Extract the seconds.' ],
        [ 'code' => 'let arrCopy = arr.slice();', 'description' => 'This line creates a shallow copy of the array arr using the slice method and assigns the result to a variable named arrCopy. The slice method, when called without arguments, returns a new array that is a shallow copy of the original array. This operation is useful for creating duplicates of arrays, such as when you want to preserve the original array but work with a copy. By storing the result in a variable, you can use the copied array independently of the original. This pattern is common in data manipulation, algorithm implementation, and any context where you need to work with array duplicates. Note that slice() performs a shallow copy, so if the array contains objects, the references to the objects are copied, not the objects themselves. To create a deep copy of an array, you can use other methods, such as JSON.parse(JSON.stringify(arr)).', 'purpose' => 'Copy an array.' ],
        [ 'code' => 'let objCopy = Object.assign({}, obj);', 'description' => 'This line creates a shallow copy of the object obj using the Object.assign method and assigns the result to a variable named objCopy. The Object.assign method is used to copy values from one or more source objects to a target object, returning the target object. This operation is useful for duplicating objects, merging objects, or adding properties to an object. By storing the result in a variable, you can use the copied object independently of the original. This pattern is common in data manipulation, configuration management, and any context where you need to work with object duplicates. Note that Object.assign performs a shallow copy, so if the object contains nested objects, the references to the nested objects are copied, not the nested objects themselves. To create a deep copy of an object, you can use other methods, such as JSON.parse(JSON.stringify(obj)).', 'purpose' => 'Copy an object.' ],
        [ 'code' => 'let keys = Object.keys(obj);', 'description' => 'This line retrieves all the property names (keys) of the object obj as an array of strings using the Object.keys method and assigns the result to a variable named keys. The Object.keys method returns an array of a given object’s own enumerable property names, in the same order as we get with a normal loop. This operation is useful for iterating over object properties, generating lists of keys, or performing operations on multiple properties. By storing the result in a variable, you can easily use the array of keys in loops, conditions, or any logic that depends on the object’s structure. This pattern is common in data processing, object manipulation, and any context where you need to work with object properties. If you need to get the keys of an object that are not enumerable, you can use the Object.getOwnPropertyNames method instead, like this: Object.getOwnPropertyNames(obj).', 'purpose' => 'List object keys.' ],
        [ 'code' => 'let values = Object.values(obj);', 'description' => 'This line retrieves all the property values of the object obj as an array using the Object.values method and assigns the result to a variable named values. The Object.values method returns an array of a given object’s own enumerable property values, in the same order as we get with a normal loop. This operation is useful for iterating over object properties, generating lists of values, or performing operations on multiple properties. By storing the result in a variable, you can easily use the array of values in loops, conditions, or any logic that depends on the object’s data. This pattern is common in data processing, object manipulation, and any context where you need to work with object properties. If you need to get the values of an object that are not enumerable, you can use the Object.getOwnPropertyNames method in conjunction with the map method, like this: Object.getOwnPropertyNames(obj).map(key => obj[key]).', 'purpose' => 'List object values.' ],
        [ 'code' => 'let entries = Object.entries(obj);', 'description' => 'This line retrieves all the key-value pairs of the object obj as an array of arrays using the Object.entries method and assigns the result to a variable named entries. The Object.entries method returns an array of a given object’s own enumerable string-keyed property [key, value] pairs, in the same order as we get with a normal loop. This operation is useful for iterating over object properties, generating lists of entries, or performing operations on multiple properties. By storing the result in a variable, you can easily use the array of entries in loops, conditions, or any logic that depends on the object’s structure and data. This pattern is common in data processing, object manipulation, and any context where you need to work with object properties. If you need to get the entries of an object that are not enumerable, you can use the Object.getOwnPropertyNames method in conjunction with the map method, like this: Object.getOwnPropertyNames(obj).map(key => [key, obj[key]]).', 'purpose' => 'List object entries.' ],
        [ 'code' => 'let isNull = value === null;', 'description' => 'This line checks if the variable value is strictly equal to null and assigns the result (true or false) to a variable named isNull. The strict equality operator (===) checks for equality without type conversion, so the values must be of the same type and value to be considered equal. This operation is useful for validating data, controlling program flow, or implementing features that depend on the presence or absence of values. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the nullity of the value. This pattern is common in data validation, conditional logic, and any context where you need to check for null values. If you also want to check for undefined values, you can use the == operator instead, like this: value == null, which will be true for both null and undefined.', 'purpose' => 'Test for null.' ],
        [ 'code' => 'let isUndef = value === undefined;', 'description' => 'This line checks if the variable value is strictly equal to undefined and assigns the result (true or false) to a variable named isUndef. The strict equality operator (===) checks for equality without type conversion, so the values must be of the same type and value to be considered equal. This operation is useful for validating data, controlling program flow, or implementing features that depend on the presence or absence of values. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the undefined state of the value. This pattern is common in data validation, conditional logic, and any context where you need to check for undefined values. If you also want to check for null values, you can use the == operator instead, like this: value == undefined, which will be true for both null and undefined.', 'purpose' => 'Test for undefined.' ],
        [ 'code' => 'let isNaNVal = isNaN(value);', 'description' => 'This line checks if the variable value is NaN (Not-a-Number) using the isNaN function and assigns the result (true or false) to a variable named isNaNVal. The isNaN function determines whether a value is NaN or not. NaN is a special value in JavaScript that represents a value that is not a legal number. This operation is useful for validating data, especially when dealing with numeric calculations, as NaN can propagate through calculations and cause unexpected results. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the numeric validity of the value. This pattern is common in data validation, error handling, and any context where you need to work with numeric data. Note that isNaN has some quirks due to type coercion in JavaScript, so for strict type checking, you may want to use Object.is(value, NaN) instead.', 'purpose' => 'Test for NaN.' ],
        [ 'code' => 'let boolVal = Boolean(value);', 'description' => 'This line converts the variable value to a boolean value using the Boolean function and assigns the result to a variable named boolVal. The Boolean function converts any value to a boolean value (true or false) based on its truthiness. This operation is useful for ensuring that a value is treated as a boolean in logical operations, conditions, or any context where a boolean value is required. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the boolean state of the value. This pattern is common in data validation, conditional logic, and any context where you need to work with boolean values. If you need to explicitly convert a value to a boolean in a more controlled way, you can use the double NOT operator !!, like this: !!value.', 'purpose' => 'Coerce to boolean.' ],
        [ 'code' => 'let numVal = Number(value);', 'description' => 'This line converts the variable value to a number using the Number function and assigns the result to a variable named numVal. The Number function converts any value to a number, using the standard rules of type conversion in JavaScript. This operation is useful for ensuring that a value is treated as a number in mathematical calculations, comparisons, or any context where a numeric value is required. By storing the result in a variable, you can easily use it in your code to perform calculations or trigger actions based on the numeric value. This pattern is common in data processing, form handling, and any context where you need to work with numeric data. If you need to explicitly convert a value to a number in a more controlled way, you can use the unary plus operator +, like this: +value.', 'purpose' => 'Coerce to number.' ],
        [ 'code' => 'let strVal = String(value);', 'description' => 'This line converts the variable value to a string using the String function and assigns the result to a variable named strVal. The String function converts any value to a string, using the standard rules of type conversion in JavaScript. This operation is useful for ensuring that a value is treated as a string in string operations, concatenations, or any context where a string value is required. By storing the result in a variable, you can easily use it in your code to manipulate or display the value as a string. This pattern is common in data formatting, user interface development, and any context where you need to work with string data. If you need to explicitly convert a value to a string in a more controlled way, you can use the toString method, like this: value.toString().', 'purpose' => 'Coerce to string.' ],
        [ 'code' => 'let arrVal = Array.from("abc");', 'description' => 'This line creates a new array from the string "abc" using the Array.from method and assigns it to a variable named arrVal. The Array.from method creates a new, shallow-copied Array instance from an array-like or iterable object. This operation is useful for converting strings, sets, maps, or any iterable object to an array. By storing the result in a variable, you can work with the array version of the data, such as processing, displaying, or further manipulating the data. This pattern is common in data manipulation, algorithm implementation, and any context where you need to work with array duplicates. Note that Array.from creates a shallow copy, so if the string contains characters that are represented by surrogate pairs in UTF-16, each surrogate pair will be treated as a single item in the array. To create a deep copy of an array, you can use other methods, such as JSON.parse(JSON.stringify(arr)).', 'purpose' => 'Convert string to array.' ],
        [ 'code' => 'let arrOf = Array.of(1,2,3);', 'description' => 'This line creates a new array from the arguments 1, 2, and 3 using the Array.of method and assigns it to a variable named arrOf. The Array.of method creates a new Array instance from a variable number of arguments, regardless of their number or type. This operation is useful for creating arrays with specific values, such as when you want to initialize an array with certain elements. By storing the result in a variable, you can work with the newly created array, such as processing, displaying, or further manipulating the data. This pattern is common in data initialization, configuration, and any context where you need to create arrays with specific values. If you need to create an array from an existing array-like or iterable object, you can use the Array.from method instead, like this: Array.from(iterable).', 'purpose' => 'Create array from values.' ],
        [ 'code' => 'let fillArr = new Array(3).fill(0);', 'description' => 'This line creates a new array of length 3 and fills all its elements with the value 0 using the fill method and assigns it to a variable named fillArr. The fill method changes all elements in an array to a static value, from a start index to an end index (defaulting to the entire array), and returns the modified array. This operation is useful for initializing arrays with default values, such as when you want to create an array of zeros, empty strings, or any other placeholder value. By storing the result in a variable, you can work with the filled array, such as processing, displaying, or further manipulating the data. This pattern is common in data initialization, configuration, and any context where you need to create arrays with default values. If you need to fill an array with values from another array or iterable, you can use the Array.from method in conjunction with the map method, like this: Array.from({length: 3}, (_, i) => i + 1).', 'purpose' => 'Fill an array with values.' ],
        [ 'code' => 'let repeatStr = "a".repeat(3);', 'description' => 'This line creates a new string by repeating the string "a" three times using the repeat method and assigns it to a variable named repeatStr. The repeat method returns a new string which contains the specified number of copies of the string on which it was called, concatenated together. This operation is useful for creating repeated patterns, such as when generating test data, creating animations, or any scenario where you need a repeated sequence of characters. By storing the result in a variable, you can work with the repeated string, such as processing, displaying, or further manipulating the data. This pattern is common in string manipulation, data generation, and any context where you need to create repeated text. If you need to repeat a string with a different separator or pattern, you can use the split and join methods, like this: "a".split("").join("-").', 'purpose' => 'Repeat a string.' ],
        [ 'code' => 'let padStr = "5".padStart(2, "0");', 'description' => 'This line pads the string "5" on the left with zeros until it reaches a length of 2 using the padStart method and assigns the result to a variable named padStr. The padStart method pads the current string with another string (in this case, "0") until the resulting string reaches the given length (in this case, 2). This operation is useful for formatting numbers or strings to a specific length, such as when displaying prices, quantities, or any data that requires a fixed width. By storing the result in a variable, you can work with the padded string, such as processing, displaying, or further manipulating the data. This pattern is common in data formatting, user interface development, and any context where you need to ensure consistent string lengths. If you also need to pad the string on the right, you can use the padEnd method in conjunction with the padStart method, like this: "5".padStart(2, "0").padEnd(3, "0").', 'purpose' => 'Pad a string.' ],
        [ 'code' => 'let padEndStr = "5".padEnd(2, "0");', 'description' => 'This line pads the string "5" on the right with zeros until it reaches a length of 2 using the padEnd method and assigns the result to a variable named padEndStr. The padEnd method pads the current string with another string (in this case, "0") until the resulting string reaches the given length (in this case, 2). This operation is useful for formatting numbers or strings to a specific length, such as when displaying prices, quantities, or any data that requires a fixed width. By storing the result in a variable, you can work with the padded string, such as processing, displaying, or further manipulating the data. This pattern is common in data formatting, user interface development, and any context where you need to ensure consistent string lengths. If you also need to pad the string on the left, you can use the padStart method in conjunction with the padEnd method, like this: "5".padEnd(2, "0").padStart(3, "0").', 'purpose' => 'Pad a string at the end.' ],
        [ 'code' => 'let starts = str.startsWith("a");', 'description' => 'This line checks if the string str starts with the character "a" using the startsWith method and assigns the result (true or false) to a variable named starts. The startsWith method determines whether a string begins with the characters of a specified string, returning true or false as appropriate. This operation is useful for validation, conditional logic, or implementing features like "autocomplete", where you need to check if a value starts with a certain pattern. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the starting characters of the string. This pattern is common in data validation, string manipulation, and any context where you need to work with string prefixes. If you need to check for a substring that may appear anywhere in the string, you can use the includes method instead, like this: str.includes("a").', 'purpose' => 'Test string start.' ],
        [ 'code' => 'let ends = str.endsWith("z");', 'description' => 'This line checks if the string str ends with the character "z" using the endsWith method and assigns the result (true or false) to a variable named ends. The endsWith method determines whether a string ends with the characters of a specified string, returning true or false as appropriate. This operation is useful for validation, conditional logic, or implementing features like "file type checking", where you need to ensure a string ends with a certain suffix. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the ending characters of the string. This pattern is common in data validation, string manipulation, and any context where you need to work with string suffixes. If you need to check for a substring that may appear anywhere in the string, you can use the includes method instead, like this: str.includes("z").', 'purpose' => 'Test string end.' ],
        [ 'code' => 'let find = arr.find(x => x > 2);', 'description' => 'This line finds the first element in the array arr that is greater than 2 using the find method and an arrow function as the predicate. The find method returns the value of the first element that satisfies the provided testing function, or undefined if no elements satisfy the test. This operation is useful for searching arrays, validating data, or implementing features like "autocomplete", where you need to find a matching value. By storing the result in a variable, you can easily use the found value in your code for further processing, display, or any logic that depends on the search result. This pattern is common in data validation, search functionalities, and any context where you need to find specific items in a collection. If you need to find all elements that match a certain condition, you can use the filter method instead, like this: arr.filter(x => x > 2).', 'purpose' => 'Find an element in array.' ],
        [ 'code' => 'let some = arr.some(x => x > 2);', 'description' => 'This line checks if any element in the array arr is greater than 2 using the some method and an arrow function as the predicate. The some method tests whether at least one element in the array passes the test implemented by the provided function, returning true or false as appropriate. This operation is useful for validating data, implementing features like "favorites" or "bans", or any scenario where you need to check for the existence of at least one matching element. By storing the result in a variable, you can easily use the boolean result in your code to control flow or trigger actions based on the presence or absence of matching elements. This pattern is common in data validation, conditional logic, and any context where you need to check for specific items in a collection. If you need to check if all elements match a certain condition, you can use the every method instead, like this: arr.every(x => x > 2).', 'purpose' => 'Test if any element matches.' ],
        [ 'code' => 'let every = arr.every(x => x > 0);', 'description' => 'This line checks if all elements in the array arr are greater than 0 using the every method and an arrow function as the predicate. The every method tests whether all elements in the array pass the test implemented by the provided function, returning true or false as appropriate. This operation is useful for validating data, implementing features like "age verification", or any scenario where you need to ensure all items meet certain criteria. By storing the result in a variable, you can easily use the boolean result in your code to control flow or trigger actions based on the uniformity of the elements. This pattern is common in data validation, conditional logic, and any context where you need to check that all items in a collection satisfy specific conditions. If you need to check if at least one element matches a certain condition, you can use the some method instead, like this: arr.some(x => x > 0).', 'purpose' => 'Test if all elements match.' ],
        [ 'code' => 'let forEachResult = arr.forEach(x => console.log(x));', 'description' => 'This line executes the provided function once for each array element in the array arr, in ascending order, and returns undefined. The function is called with three arguments: the value of the element, the index of the element, and the array forEach was called upon. This method is useful for executing side effects at each element of an array, such as logging, updating a user interface, or modifying external variables. However, forEach is not chainable like other array methods (e.g., map, filter) because it returns undefined. If you need to transform data, consider using map instead, and if you need to filter data, use filter.', 'purpose' => 'Iterate over an array.' ],
        [ 'code' => 'let mapResult = arr.map(x => x * 2);', 'description' => 'This line creates a new array by applying the provided function to each element in the array arr, effectively doubling each element, and returns the new array. The map method is useful for transforming data, such as converting an array of temperatures in Celsius to Fahrenheit, or extracting a specific property from an array of objects. By storing the result in a variable, you can work with the new array independently of the original array. This pattern is common in data processing, API response handling, and any context where you need to transform or extract data from collections. Remember that map does not change the original array; it always returns a new array.', 'purpose' => 'Transform array elements.' ],
        [ 'code' => 'let filterResult = arr.filter(x => x > 1);', 'description' => 'This line creates a new array with all elements in the array arr that pass the test implemented by the provided function, effectively filtering out elements that do not match the criteria (in this case, elements that are greater than 1), and returns the new array. The filter method is useful for selecting a subset of data, such as finding all users older than 18 in an array of user objects, or removing all null or undefined values from an array. By storing the result in a variable, you can work with the filtered array independently of the original array. This pattern is common in data processing, validation, and any context where you need to work with a subset of a collection. Note that filter does not change the original array; it always returns a new array.', 'purpose' => 'Filter array elements.' ],
        [ 'code' => 'let reduceResult = arr.reduce((a, b) => a + b, 0);', 'description' => 'This line applies the provided function against an accumulator and each element in the array arr (from left to right) to reduce it to a single value (in this case, the sum of all elements), and returns the single value. The reduce method is useful for aggregating data, such as calculating the total price of items in a cart, finding the maximum or minimum value in a list, or flattening an array of arrays. By storing the result in a variable, you can use the reduced value in further calculations, display it, or store it. This pattern is common in data processing, mathematical computations, and any context where you need to derive a single value from a collection of values. If you need to perform multiple operations on the array, consider using a forEach loop instead, which can be more flexible.', 'purpose' => 'Reduce array to a value.' ],
        [ 'code' => 'let findIndex = arr.findIndex(x => x === 2);', 'description' => 'This line finds the index of the first element in the array arr that is strictly equal to 2 using the findIndex method and an arrow function as the predicate. The findIndex method returns the index of the element if found, or -1 if the element is not present in the array. This operation is useful for searching elements in an array, validating data, or implementing features like "autocomplete", where you need to find a matching value. By storing the result in a variable, you can easily use the found index in your code for further processing, display, or any logic that depends on the search result. This pattern is common in data validation, search functionalities, and any context where you need to find specific items in a collection. If you need to find all elements that match a certain condition, you can use the filter method instead, like this: arr.filter(x => x === 2).', 'purpose' => 'Find index in array.' ],
        [ 'code' => 'let flatArr = [1, [2, 3]].flat();', 'description' => 'This line creates a new array with all sub-array elements concatenated into it recursively up to the specified depth (in this case, depth of 1) using the flat method and assigns the result to a variable named flatArr. The flat method is useful for flattening nested arrays, such as when you have an array of arrays and you want to create a single-level array with all the values. By storing the result in a variable, you can work with the flattened array, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, API response handling, and any context where you need to work with nested collections. If you need to flatten an array with unknown depth, you can pass Infinity as the depth argument, like this: arr.flat(Infinity).', 'purpose' => 'Flatten an array.' ],
        [ 'code' => 'let flatMapArr = arr.flatMap(x => [x, x * 2]);', 'description' => 'This line first maps each element in the array arr to a new array (in this case, an array containing the element and its double) using the map method, and then flattens the result into a new array with all sub-array elements concatenated into it recursively up to the specified depth (in this case, depth of 1) using the flat method. The flatMap method is useful for combining map and flatten operations into one, such as when you want to transform data and reduce the nesting of arrays in a single step. By storing the result in a variable, you can work with the flattened and mapped array, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, API response handling, and any context where you need to transform and flatten data simultaneously. If you need to perform more complex transformations or flattening with different depths, you can use the map and flat methods separately, like this: arr.map(x => [x, x * 2]).flat().', 'purpose' => 'FlatMap an array.' ],
        [ 'code' => 'let symbol = Symbol("id");', 'description' => 'This line creates a new unique symbol with the description "id" using the Symbol function and assigns it to a variable named symbol. Symbols are a new primitive data type introduced in ES6 that are immutable and can be used as unique object keys. This operation is useful for creating unique identifiers for object properties, such as when you want to avoid name clashes between properties or when you need a unique value that no other code can accidentally overwrite. By storing the result in a variable, you can use the symbol as a key for object properties, such as obj[symbol] = "value". This pattern is common in library and framework development, where you need to create unique keys for internal use. Note that symbols are not visible in for...in loops and Object.keys, so they are not enumerable like regular object properties.', 'purpose' => 'Create a unique identifier.' ],
        [ 'code' => 'let set = new Set([1,2,2,3]);', 'description' => 'This line creates a new Set object from the array [1,2,2,3], which will automatically remove the duplicate value 2, using the Set constructor and assigns it to a variable named set. A Set is a built-in JavaScript object that lets you store unique values of any type, whether primitive values or object references. This operation is useful for storing values that must be unique, such as when you want to ensure that a list of items has no duplicates. By storing the result in a variable, you can work with the set of values, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, algorithm implementation, and any context where you need to work with unique values. If you need to create a Set from an existing array or iterable object, you can use the Set constructor, like this: new Set(iterable).', 'purpose' => 'Remove duplicates from array.' ],
        [ 'code' => 'let map = new Map([["a", 1], ["b", 2]]);', 'description' => 'This line creates a new Map object from the array of key-value pairs [["a", 1], ["b", 2]] using the Map constructor and assigns it to a variable named map. A Map is a built-in JavaScript object that lets you store key-value pairs where the keys can be of any type, and remembers the original insertion order of the keys. This operation is useful for storing data that needs to be associated with specific keys, such as when you want to implement a dictionary, cache, or any associative array. By storing the result in a variable, you can work with the map of key-value pairs, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, configuration management, and any context where you need to work with key-value pairs. If you need to create a Map from an existing object, you can use the Object.entries method in conjunction with the Map constructor, like this: new Map(Object.entries(obj)).', 'purpose' => 'Store key-value pairs.' ],
        [ 'code' => 'let arrFromSet = Array.from(set);', 'description' => 'This line creates a new array from the Set object set using the Array.from method and assigns it to a variable named arrFromSet. The Array.from method creates a new, shallow-copied Array instance from an array-like or iterable object. This operation is useful for converting Sets, Maps, or any iterable object to arrays. By storing the result in a variable, you can work with the array version of the data, such as processing, displaying, or further manipulating the data. This pattern is common in data manipulation, algorithm implementation, and any context where you need to work with array duplicates. Note that Array.from creates a shallow copy, so if the Set contains objects, the references to the objects are copied, not the objects themselves. To create a deep copy of an array, you can use other methods, such as JSON.parse(JSON.stringify(arr)).', 'purpose' => 'Convert Set to array.' ],
        [ 'code' => 'let arrFromMap = Array.from(map);', 'description' => 'This line creates a new array from the Map object map using the Array.from method and assigns it to a variable named arrFromMap. The Array.from method creates a new, shallow-copied Array instance from an array-like or iterable object. This operation is useful for converting Maps, Sets, or any iterable object to arrays. By storing the result in a variable, you can work with the array version of the data, such as processing, displaying, or further manipulating the data. This pattern is common in data manipulation, algorithm implementation, and any context where you need to work with array duplicates. Note that Array.from creates a shallow copy, so if the Map contains objects, the references to the objects are copied, not the objects themselves. To create a deep copy of an array, you can use other methods, such as JSON.parse(JSON.stringify(arr)).', 'purpose' => 'Convert Map to array.' ],
        [ 'code' => 'let keyExists = map.has("a");', 'description' => 'This line checks if the Map object map has the key "a" using the has method and assigns the result (true or false) to a variable named keyExists. The has method returns a boolean indicating whether the specified key exists in the Map object. This operation is useful for validating data, controlling program flow, or implementing features that depend on the presence or absence of keys. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the existence of the key. This pattern is common in data validation, conditional logic, and any context where you need to check for specific keys in a Map. If you need to check for the existence of a value in a Set, you can use the has method of the Set object, like this: set.has(value).', 'purpose' => 'Check for key in Map.' ],
        [ 'code' => 'let setHas = set.has(2);', 'description' => 'This line checks if the Set object set contains the value 2 using the has method and assigns the result (true or false) to a variable named setHas. The has method returns a boolean indicating whether the specified value exists in the Set object. This operation is useful for validating data, controlling program flow, or implementing features that depend on the presence or absence of values. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the presence or absence of the value. This pattern is common in data validation, conditional logic, and any context where you need to check for specific values in a Set. If you need to check for the existence of a key in a Map, you can use the has method of the Map object, like this: map.has(key).', 'purpose' => 'Check for value in Set.' ],
        [ 'code' => 'let arrKeys = Object.keys(arr);', 'description' => 'This line retrieves all the keys (indices as strings) of the array arr as an array of strings using the Object.keys method and assigns the result to a variable named arrKeys. The Object.keys method returns an array of a given object’s own enumerable property names, in the same order as we get with a normal loop. This operation is useful for iterating over array indices, generating lists of indices, or performing operations on multiple elements. By storing the result in a variable, you can easily use the array of keys in loops, conditions, or any logic that depends on the array’s structure. This pattern is common in data processing, array manipulation, and any context where you need to work with array indices. If you need to get the keys of an object that are not enumerable, you can use the Object.getOwnPropertyNames method instead, like this: Object.getOwnPropertyNames(obj).', 'purpose' => 'List array indices.' ],
        [ 'code' => 'let arrValues = Object.values(arr);', 'description' => 'This line retrieves all the values of the array arr as an array using the Object.values method and assigns the result to a variable named arrValues. The Object.values method returns an array of a given object’s own enumerable property values, in the same order as we get with a normal loop. This operation is useful for iterating over array values, generating lists of values, or performing operations on multiple elements. By storing the result in a variable, you can easily use the array of values in loops, conditions, or any logic that depends on the array’s data. This pattern is common in data processing, array manipulation, and any context where you need to work with array values. If you need to get the values of an object that are not enumerable, you can use the Object.getOwnPropertyNames method in conjunction with the map method, like this: Object.getOwnPropertyNames(obj).map(key => obj[key]).', 'purpose' => 'List array values.' ],
        [ 'code' => 'let arrEntries = Object.entries(arr);', 'description' => 'This line retrieves all the key-value pairs of the array arr as an array of arrays using the Object.entries method and assigns the result to a variable named arrEntries. The Object.entries method returns an array of a given object’s own enumerable string-keyed property [key, value] pairs, in the same order as we get with a normal loop. This operation is useful for iterating over array entries, generating lists of entries, or performing operations on multiple elements. By storing the result in a variable, you can easily use the array of entries in loops, conditions, or any logic that depends on the array’s structure and data. This pattern is common in data processing, array manipulation, and any context where you need to work with array key-value pairs. If you need to get the entries of an object that are not enumerable, you can use the Object.getOwnPropertyNames method in conjunction with the map method, like this: Object.getOwnPropertyNames(obj).map(key => [key, obj[key]]).', 'purpose' => 'List array entries.' ],
        [ 'code' => 'let boolNum = +true;', 'description' => 'This line converts the boolean value true to the number 1 using the unary plus operator (+) and assigns the result to a variable named boolNum. The unary plus operator is a quick way to convert a boolean value to a number in JavaScript, where true becomes 1 and false becomes 0. This operation is useful for performing arithmetic operations with boolean values, such as when you want to count the number of true values in an array or toggle a value between 0 and 1. By storing the result in a variable, you can use the numeric value in further calculations, comparisons, or any logic that depends on the numeric representation of the boolean value. This pattern is common in data processing, mathematical computations, and any context where you need to work with boolean values as numbers. If you need to convert a number back to a boolean, you can use the Boolean function, like this: Boolean(num).', 'purpose' => 'Coerce boolean to number.' ],
        [ 'code' => 'let numBool = !!1;', 'description' => 'This line converts the number 1 to the boolean value true using the double NOT operator (!!) and assigns the result to a variable named numBool. The double NOT operator is a common trick in JavaScript to convert a value to a boolean, where the first NOT operator negates the value, and the second NOT operator negates it again, resulting in a boolean value that represents the truthiness or falsiness of the original value. This operation is useful for ensuring that a value is treated as a boolean in logical operations, conditions, or any context where a boolean value is required. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the boolean state of the value. This pattern is common in data validation, conditional logic, and any context where you need to work with boolean values. If you need to explicitly convert a value to a boolean in a more controlled way, you can use the Boolean function, like this: Boolean(value).', 'purpose' => 'Coerce number to boolean.' ],
        [ 'code' => 'let zeroBool = Boolean(0);', 'description' => 'This line converts the number 0 to the boolean value false using the Boolean function and assigns the result to a variable named zeroBool. The Boolean function converts any value to a boolean value (true or false) based on its truthiness. This operation is useful for ensuring that a value is treated as a boolean in logical operations, conditions, or any context where a boolean value is required. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the boolean state of the value. This pattern is common in data validation, conditional logic, and any context where you need to work with boolean values. If you need to explicitly convert a value to a boolean in a more controlled way, you can use the double NOT operator !!, like this: !!value.', 'purpose' => 'Coerce zero to boolean.' ],
        [ 'code' => 'let emptyStrBool = Boolean("");', 'description' => 'This line converts the empty string "" to the boolean value false using the Boolean function and assigns the result to a variable named emptyStrBool. The Boolean function converts any value to a boolean value (true or false) based on its truthiness. This operation is useful for ensuring that a value is treated as a boolean in logical operations, conditions, or any context where a boolean value is required. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the boolean state of the value. This pattern is common in data validation, conditional logic, and any context where you need to work with boolean values. If you need to explicitly convert a value to a boolean in a more controlled way, you can use the double NOT operator !!, like this: !!value.', 'purpose' => 'Coerce empty string to boolean.' ],
        [ 'code' => 'let arrBool = Boolean([]);', 'description' => 'This line converts the empty array [] to the boolean value true using the Boolean function and assigns the result to a variable named arrBool. The Boolean function converts any value to a boolean value (true or false) based on its truthiness. This operation is useful for ensuring that a value is treated as a boolean in logical operations, conditions, or any context where a boolean value is required. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the boolean state of the value. This pattern is common in data validation, conditional logic, and any context where you need to work with boolean values. If you need to explicitly convert a value to a boolean in a more controlled way, you can use the double NOT operator !!, like this: !!value.', 'purpose' => 'Test truthiness of array.' ],
        [ 'code' => 'let objBool = Boolean({});', 'description' => 'This line converts the empty object {} to the boolean value true using the Boolean function and assigns the result to a variable named objBool. The Boolean function converts any value to a boolean value (true or false) based on its truthiness. This operation is useful for ensuring that a value is treated as a boolean in logical operations, conditions, or any context where a boolean value is required. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the boolean state of the value. This pattern is common in data validation, conditional logic, and any context where you need to work with boolean values. If you need to explicitly convert a value to a boolean in a more controlled way, you can use the double NOT operator !!, like this: !!value.', 'purpose' => 'Test truthiness of object.' ],
        [ 'code' => 'let notTrue = !true;', 'description' => 'This line negates the boolean value true, resulting in false, using the logical NOT operator (!) and assigns the result to a variable named notTrue. The logical NOT operator inverts the truthiness of a value, so true becomes false, and false becomes true. This operation is useful for toggling boolean values, implementing features like "mute" or "disable", or any scenario where you need to invert a condition. By storing the result in a variable, you can use the negated value in further calculations, comparisons, or any logic that depends on the boolean value. This pattern is common in data processing, conditional logic, and any context where you need to work with boolean values. If you need to negate a value that may be null or undefined, you can use the nullish coalescing operator ??, like this: value ?? "default".', 'purpose' => 'Negate a boolean.' ],
        [ 'code' => 'let notFalse = !false;', 'description' => 'This line negates the boolean value false, resulting in true, using the logical NOT operator (!) and assigns the result to a variable named notFalse. The logical NOT operator inverts the truthiness of a value, so true becomes false, and false becomes true. This operation is useful for toggling boolean values, implementing features like "mute" or "disable", or any scenario where you need to invert a condition. By storing the result in a variable, you can use the negated value in further calculations, comparisons, or any logic that depends on the boolean value. This pattern is common in data processing, conditional logic, and any context where you need to work with boolean values. If you need to negate a value that may be null or undefined, you can use the nullish coalescing operator ??, like this: value ?? "default".', 'purpose' => 'Negate a boolean.' ],
        [ 'code' => 'let doubleNot = !!value;', 'description' => 'This line converts the variable value to a boolean value using the double NOT operator (!!) and assigns the result to a variable named doubleNot. The double NOT operator is a common trick in JavaScript to convert a value to a boolean, where the first NOT operator negates the value, and the second NOT operator negates it again, resulting in a boolean value that represents the truthiness or falsiness of the original value. This operation is useful for ensuring that a value is treated as a boolean in logical operations, conditions, or any context where a boolean value is required. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the boolean state of the value. This pattern is common in data validation, conditional logic, and any context where you need to work with boolean values. If you need to explicitly convert a value to a boolean in a more controlled way, you can use the Boolean function, like this: Boolean(value).', 'purpose' => 'Coerce to boolean.' ],
        [ 'code' => 'let ternary = x > 0 ? "positive" : "non-positive";', 'description' => 'This line uses the ternary operator (also known as the conditional operator) to assign the string "positive" to the variable ternary if the variable x is greater than 0, and "non-positive" otherwise. The ternary operator is a shorthand for the if-else statement and is useful for making simple conditional assignments. By using the ternary operator, you can write more concise and potentially more readable code for simple conditions. This pattern is common in data processing, configuration, and any context where you need to make simple decisions based on variable values. If the condition is more complex or requires multiple statements, it is generally better to use a regular if-else statement for clarity, like this: if (x > 0) { ternary = "positive"; } else { ternary = "non-positive"; }.', 'purpose' => 'Short conditional logic.' ],
        [ 'code' => 'let andResult = a && b;', 'description' => 'This line performs a logical AND operation on the variables a and b, and assigns the result to a variable named andResult. The && operator in JavaScript returns the value of the first operand if it can be converted to false; otherwise, it returns the value of the second operand. This operation is useful for combining multiple conditions into a single boolean expression, such as when you want to check if a user is logged in and has admin privileges. By storing the result in a variable, you can use the combined boolean value in further calculations, comparisons, or any logic that depends on multiple conditions. This pattern is common in data validation, access control, and any context where you need to combine multiple boolean values. If you need to perform a bitwise AND operation instead, you can use the & operator, like this: a & b.', 'purpose' => 'Combine two conditions.' ],
        [ 'code' => 'let orResult = a || b;', 'description' => 'This line performs a logical OR operation on the variables a and b, and assigns the result to a variable named orResult. The || operator in JavaScript returns the value of the first operand if it can be converted to true; otherwise, it returns the value of the second operand. This operation is useful for combining multiple conditions into a single boolean expression, such as when you want to check if a user is logged in or has a valid session. By storing the result in a variable, you can use the combined boolean value in further calculations, comparisons, or any logic that depends on multiple conditions. This pattern is common in data validation, access control, and any context where you need to combine multiple boolean values. If you need to perform a bitwise OR operation instead, you can use the | operator, like this: a | b.', 'purpose' => 'Combine two conditions.' ],
        [ 'code' => 'let notResult = !a;', 'description' => 'This line negates the boolean value of the variable a using the logical NOT operator (!) and assigns the result to a variable named notResult. The logical NOT operator inverts the truthiness of a value, so true becomes false, and false becomes true. This operation is useful for toggling boolean values, implementing features like "mute" or "disable", or any scenario where you need to invert a condition. By storing the result in a variable, you can use the negated value in further calculations, comparisons, or any logic that depends on the boolean value. This pattern is common in data processing, conditional logic, and any context where you need to work with boolean values. If you need to negate a value that may be null or undefined, you can use the nullish coalescing operator ??, like this: value ?? "default".', 'purpose' => 'Negate a condition.' ],
        [ 'code' => 'let inc = ++x;', 'description' => 'This line increments the value of the variable x by 1 using the pre-increment operator (++) and assigns the new value to the variable inc. The pre-increment operator increases the value of a variable by 1 before the value is used in an expression. This operation is useful for incrementing counters, updating values, or any scenario where you need to increase a value. By storing the result in a variable, you can use the incremented value in further calculations, comparisons, or any logic that depends on the updated value. This pattern is common in loops, counters, and any context where you need to increment values. If you need to increment a value conditionally, you can use the ternary operator, like this: x > 0 ? ++x : x.', 'purpose' => 'Increase a value.' ],
        [ 'code' => 'let dec = --x;', 'description' => 'This line decrements the value of the variable x by 1 using the pre-decrement operator (--) and assigns the new value to the variable dec. The pre-decrement operator decreases the value of a variable by 1 before the value is used in an expression. This operation is useful for decrementing counters, updating values, or any scenario where you need to decrease a value. By storing the result in a variable, you can use the decremented value in further calculations, comparisons, or any logic that depends on the updated value. This pattern is common in loops, counters, and any context where you need to decrement values. If you need to decrement a value conditionally, you can use the ternary operator, like this: x < 10 ? --x : x.', 'purpose' => 'Decrease a value.' ],
        [ 'code' => 'let postInc = x++;', 'description' => 'This line increments the value of the variable x by 1 using the post-increment operator (++) and assigns the original value of x to the variable postInc. The post-increment operator increases the value of a variable by 1 after the value is used in an expression. This operation is useful for incrementing counters, updating values, or any scenario where you need to increase a value but also use the original value in the same expression. By storing the result in a variable, you can use the original value of x before the increment in further calculations, comparisons, or any logic that depends on the original value. This pattern is common in loops, counters, and any context where you need to increment values but also use the original value. If you need to increment a value conditionally, you can use the ternary operator, like this: x > 0 ? x++ : x.', 'purpose' => 'Increase after use.' ],
        [ 'code' => 'let postDec = x--;', 'description' => 'This line decrements the value of the variable x by 1 using the post-decrement operator (--) and assigns the original value of x to the variable postDec. The post-decrement operator decreases the value of a variable by 1 after the value is used in an expression. This operation is useful for decrementing counters, updating values, or any scenario where you need to decrease a value but also use the original value in the same expression. By storing the result in a variable, you can use the original value of x before the decrement in further calculations, comparisons, or any logic that depends on the original value. This pattern is common in loops, counters, and any context where you need to decrement values but also use the original value. If you need to decrement a value conditionally, you can use the ternary operator, like this: x < 10 ? x-- : x.', 'purpose' => 'Decrease after use.' ],
        [ 'code' => 'let assign = (x = 5);', 'description' => 'This line assigns the value 5 to the variable x using the assignment operator (=) and assigns the value of x (which is now 5) to the variable assign. The assignment operator assigns the value of the right-hand operand to the left-hand operand. This operation is useful for setting initial values, updating values, or any scenario where you need to assign a value to a variable. By storing the result in a variable, you can use the assigned value in further calculations, comparisons, or any logic that depends on the value of x. This pattern is common in variable initialization, configuration, and any context where you need to work with assigned values. If you need to perform multiple assignments in a single statement, you can chain the assignment operator, like this: a = b = c = 10.', 'purpose' => 'Assignment operation.' ],
        [ 'code' => 'let addAssign = (x += 2);', 'description' => 'This line adds 2 to the current value of the variable x using the addition assignment operator (+=) and assigns the new value to the variable addAssign. The addition assignment operator adds the right-hand operand to the left-hand operand and assigns the result to the left-hand operand. This operation is useful for incrementing values, updating totals, or any scenario where you need to add a value to an existing variable. By storing the result in a variable, you can use the updated value in further calculations, comparisons, or any logic that depends on the new value of x. This pattern is common in counters, accumulators, and any context where you need to update values based on their current state. If you need to perform multiple updates in a single statement, you can chain the addition assignment operator, like this: x += 2 += 3.', 'purpose' => 'Compound assignment.' ],
        [ 'code' => 'let subAssign = (x -= 2);', 'description' => 'This line subtracts 2 from the current value of the variable x using the subtraction assignment operator (-=) and assigns the new value to the variable subAssign. The subtraction assignment operator subtracts the right-hand operand from the left-hand operand and assigns the result to the left-hand operand. This operation is useful for decrementing values, updating differences, or any scenario where you need to subtract a value from an existing variable. By storing the result in a variable, you can use the updated value in further calculations, comparisons, or any logic that depends on the new value of x. This pattern is common in counters, timers, and any context where you need to update values based on their current state. If you need to perform multiple updates in a single statement, you can chain the subtraction assignment operator, like this: x -= 2 -= 3.', 'purpose' => 'Compound assignment.' ],
        [ 'code' => 'let mulAssign = (x *= 2);', 'description' => 'This line multiplies the current value of the variable x by 2 using the multiplication assignment operator (*=) and assigns the new value to the variable mulAssign. The multiplication assignment operator multiplies the left-hand operand by the right-hand operand and assigns the result to the left-hand operand. This operation is useful for scaling values, updating products, or any scenario where you need to multiply an existing variable by a value. By storing the result in a variable, you can use the updated value in further calculations, comparisons, or any logic that depends on the new value of x. This pattern is common in mathematical computations, data processing, and any context where you need to update values based on their current state. If you need to perform multiple updates in a single statement, you can chain the multiplication assignment operator, like this: x *= 2 *= 3.', 'purpose' => 'Compound assignment.' ],
        [ 'code' => 'let divAssign = (x /= 2);', 'description' => 'This line divides the current value of the variable x by 2 using the division assignment operator (/=) and assigns the new value to the variable divAssign. The division assignment operator divides the left-hand operand by the right-hand operand and assigns the result to the left-hand operand. This operation is useful for scaling values, updating ratios, or any scenario where you need to divide an existing variable by a value. By storing the result in a variable, you can use the updated value in further calculations, comparisons, or any logic that depends on the new value of x. This pattern is common in mathematical computations, data processing, and any context where you need to update values based on their current state. If you need to perform multiple updates in a single statement, you can chain the division assignment operator, like this: x /= 2 /= 3.', 'purpose' => 'Compound assignment.' ],
        [ 'code' => 'let modAssign = (x %= 2);', 'description' => 'This line calculates the remainder of the division of the current value of the variable x by 2 using the remainder assignment operator (%=) and assigns the new value to the variable modAssign. The remainder assignment operator calculates the remainder of dividing the left-hand operand by the right-hand operand and assigns the result to the left-hand operand. This operation is useful for toggling between two values, implementing binary flags, or any scenario where you need to calculate the remainder of a division. By storing the result in a variable, you can use the updated value in further calculations, comparisons, or any logic that depends on the new value of x. This pattern is common in mathematical computations, data processing, and any context where you need to update values based on their current state. If you need to perform multiple updates in a single statement, you can chain the remainder assignment operator, like this: x %= 2 %= 3.', 'purpose' => 'Compound assignment.' ],
        [ 'code' => 'let pow = 2 ** 3;', 'description' => 'This line raises the base 2 to the exponent 3 using the exponentiation operator (**) and assigns the result to a variable named pow. The exponentiation operator raises the left-hand operand to the power of the right-hand operand, returning the result. This operation is useful for performing power calculations, such as calculating squares, cubes, or any exponentiation. By storing the result in a variable, you can use the calculated power in further calculations, comparisons, or any logic that depends on the exponentiated value. This pattern is common in mathematical computations, data processing, and any context where you need to perform power calculations. If you need to perform multiple exponentiations in a single statement, you can chain the exponentiation operator, like this: 2 ** 3 ** 4.', 'purpose' => 'Exponentiation.' ],
        [ 'code' => 'let powAssign = (x **= 2);', 'description' => 'This line raises the current value of the variable x to the power of 2 using the exponentiation assignment operator (**=) and assigns the new value to the variable powAssign. The exponentiation assignment operator raises the left-hand operand to the power of the right-hand operand and assigns the result to the left-hand operand. This operation is useful for performing power calculations and updating the value in a single step, such as calculating squares, cubes, or any exponentiation. By storing the result in a variable, you can use the updated power value in further calculations, comparisons, or any logic that depends on the new value of x. This pattern is common in mathematical computations, data processing, and any context where you need to update values based on their current state. If you need to perform multiple updates in a single statement, you can chain the exponentiation assignment operator, like this: x **= 2 **= 3.', 'purpose' => 'Compound exponentiation.' ],
        [ 'code' => 'let nullish = value ?? "default";', 'description' => 'This line assigns the value of the variable value to the variable nullish if value is not null or undefined; otherwise, it assigns the string "default". The nullish coalescing operator (??) is useful for providing default values for potentially null or undefined variables, such as when you want to ensure a variable has a valid value before using it. By storing the result in a variable, you can use the determined value in further calculations, comparisons, or any logic that depends on the value. This pattern is common in data validation, configuration, and any context where you need to provide fallback values. If you need to provide a default value for a variable that may be falsy (e.g., 0, "", false), you can use the || operator instead, like this: value || "default".', 'purpose' => 'Default for null/undefined.' ],
        [ 'code' => 'let optChain = obj?.prop;', 'description' => 'This line accesses the prop property of the object obj if obj is not null or undefined; otherwise, it returns undefined. The optional chaining operator (?.) is useful for safely accessing deeply nested properties of an object without having to check each level for null or undefined. By storing the result in a variable, you can use the accessed value in further calculations, comparisons, or any logic that depends on the value. This pattern is common in data processing, API response handling, and any context where you need to safely access nested object properties. If you need to provide a default value for a potentially undefined property, you can use the nullish coalescing operator ?? in conjunction with optional chaining, like this: obj?.prop ?? "default".', 'purpose' => 'Safe property access.' ],
        [ 'code' => 'let arrSpread = [...arr];', 'description' => 'This line creates a shallow copy of the array arr using the spread operator (...) and assigns the result to a variable named arrSpread. The spread operator allows an iterable such as an array to be expanded in places where zero or more arguments or elements are expected. This operation is useful for creating duplicates of arrays, merging arrays, or adding elements to arrays. By storing the result in a variable, you can work with the copied array independently of the original array. This pattern is common in data manipulation, algorithm implementation, and any context where you need to work with array duplicates. Note that the spread operator creates a shallow copy, so if the array contains objects, the references to the objects are copied, not the objects themselves. To create a deep copy of an array, you can use other methods, such as JSON.parse(JSON.stringify(arr)).', 'purpose' => 'Copy an array.' ],
        [ 'code' => 'let objSpread = {...obj};', 'description' => 'This line creates a shallow copy of the object obj using the spread operator (...) and assigns the result to a variable named objSpread. The spread operator allows an iterable such as an array to be expanded in places where zero or more arguments or elements are expected. This operation is useful for creating duplicates of objects, merging objects, or adding properties to objects. By storing the result in a variable, you can work with the copied object independently of the original object. This pattern is common in data manipulation, configuration management, and any context where you need to work with object duplicates. Note that the spread operator creates a shallow copy, so if the object contains nested objects, the references to the nested objects are copied, not the nested objects themselves. To create a deep copy of an object, you can use other methods, such as JSON.parse(JSON.stringify(obj)).', 'purpose' => 'Copy an object.' ],
        [ 'code' => 'let arrDestruct = [a, b] = [1, 2];', 'description' => 'This line uses array destructuring to extract the first two elements from the array [1, 2] and assign them to the variables a and b, respectively. Array destructuring is a convenient way to extract values from arrays or array-like objects and assign them to variables in a concise manner. This operation is useful for unpacking values from arrays, such as when you want to get the first and second elements of an array and use them as separate variables. By using array destructuring, you can write more readable and maintainable code, as it reduces the need for temporary variables and makes the intent of the code clearer. This pattern is common in data processing, API response handling, and any context where you need to work with array duplicates. If you need to extract values from an object instead of an array, you can use object destructuring, like this: const {x, y} = {x:1, y:2}.', 'purpose' => 'Extract values from array.' ],
        [ 'code' => 'let objDestruct = {x, y} = {x:1, y:2};', 'description' => 'This line uses object destructuring to extract the x and y properties from the object {x:1, y:2} and assign them to the variables x and y, respectively. Object destructuring is a convenient way to extract values from objects and assign them to variables in a concise manner. This operation is useful for unpacking values from objects, such as when you want to get the properties of an object and use them as separate variables. By using object destructuring, you can write more readable and maintainable code, as it reduces the need for temporary variables and makes the intent of the code clearer. This pattern is common in data processing, API response handling, and any context where you need to work with object duplicates. If you need to extract values from an array instead of an object, you can use array destructuring, like this: const [a, b] = [1, 2].', 'purpose' => 'Extract values from object.' ],
        [ 'code' => 'let restArr = [first, ...rest] = arr;', 'description' => 'This line uses the rest operator (...) in array destructuring to extract the first element of the array arr and assign it to the variable first, and the remaining elements to the variable rest as an array. The rest operator allows you to represent an indefinite number of arguments as an array. This operation is useful for separating the first element from the rest of the elements in an array, such as when you want to process the first item differently or pass the rest of the items to another function. By using the rest operator, you can write more flexible and reusable code, as it allows you to handle variable numbers of elements. This pattern is common in data processing, event handling, and any context where you need to work with variable arguments. If you need to collect all remaining properties of an object in object destructuring, you can use the rest operator in conjunction with object destructuring, like this: const {a, ...rest} = obj.', 'purpose' => 'Get remaining elements.' ],
        [ 'code' => 'let restObj = {a, ...others} = obj;', 'description' => 'This line uses the rest operator (...) in object destructuring to extract the a property from the object obj and assign it to the variable a, and the remaining properties to the variable others as an object. The rest operator allows you to represent an indefinite number of arguments as an array or object. This operation is useful for separating a specific property from the rest of the properties in an object, such as when you want to process a configuration option separately or pass the rest of the options to another function. By using the rest operator, you can write more flexible and reusable code, as it allows you to handle variable numbers of properties. This pattern is common in data processing, event handling, and any context where you need to work with variable arguments. If you need to collect all remaining elements of an array in array destructuring, you can use the rest operator in conjunction with array destructuring, like this: const [first, ...rest] = arr.', 'purpose' => 'Get remaining properties.' ],
        [ 'code' => 'let template = `Hello, ${name}`;', 'description' => 'This line uses template literals, enclosed by backticks (``), to create a string that includes the value of the variable name. Template literals are a way to include expressions inside string literals, allowing for easier and more readable string interpolation. This operation is useful for creating dynamic strings, such as when you want to include variable values or expressions in a string. By using template literals, you can write more concise and maintainable code, as it reduces the need for string concatenation or complex formatting. This pattern is common in data processing, user interface development, and any context where you need to create dynamic strings. If you need to include special characters or line breaks in the string, you can do so directly in the template literal, like this: `Line 1\nLine 2`.', 'purpose' => 'Embed variables in strings.' ],
        [ 'code' => 'let escape = "Line1\\nLine2";', 'description' => 'This line creates a string that represents two lines, "Line1" and "Line2", separated by a newline character, using an escape sequence. Escape sequences are used to represent special characters in strings, such as newline (\n), tab (\t), or backslash (\\). This operation is useful for creating strings that require special formatting, such as when generating text files, displaying messages, or any scenario where you need to include special characters. By storing the result in a variable, you can use the formatted string in further processing, display, or any logic that depends on the string content. This pattern is common in data processing, text formatting, and any context where you need to work with special characters in strings. If you need to include a literal backslash in the string, you can escape it with another backslash, like this: "C:\\Program Files\\".', 'purpose' => 'Format multi-line strings.' ],
        [ 'code' => 'let arrFill = arr.fill(0);', 'description' => 'This line fills all elements of the array arr with the value 0 using the fill method and assigns the result to a variable named arrFill. The fill method changes all elements in an array to a static value, from a start index to an end index (defaulting to the entire array), and returns the modified array. This operation is useful for initializing or resetting arrays, such as when you want to create an array of zeros, empty strings, or any other placeholder value. By storing the result in a variable, you can work with the filled array, such as processing, displaying, or further manipulating the data. This pattern is common in data initialization, configuration, and any context where you need to create arrays with default values. If you need to fill an array with values from another array or iterable, you can use the Array.from method in conjunction with the map method, like this: Array.from({length: 3}, (_, i) => i + 1).', 'purpose' => 'Overwrite all elements.' ],
        [ 'code' => 'let arrCopyWithin = arr.copyWithin(0, 1);', 'description' => 'This line copies the values from the array arr starting at index 1 to the position starting at index 0, effectively overwriting the value at index 0 with the value at index 1, using the copyWithin method and assigns the result to a variable named arrCopyWithin. The copyWithin method shallow copies part of an array to another location in the same array and returns it, without modifying its length. This operation is useful for moving or duplicating elements within the same array, such as when you want to reorder elements or create duplicates at different positions. By storing the result in a variable, you can work with the modified array, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, algorithm implementation, and any context where you need to work with array duplicates. If you need to copy elements between different arrays, you can use the Array.from method in conjunction with the map method, like this: Array.from(arr).map((v, i) => i >= 1 ? v : undefined).', 'purpose' => 'Copy array elements.' ],
        [ 'code' => 'let arrIncludes = arr.includes(2);', 'description' => 'This line checks if the array arr includes the value 2 using the includes method and assigns the result (true or false) to a variable named arrIncludes. The includes method determines whether an array includes a certain value among its entries, returning true or false as appropriate. This operation is useful for validation, conditional logic, or implementing features like "autocomplete", where you need to check if a value already exists in a list. By storing the result in a variable, you can easily use it in your code to control flow or trigger actions based on the presence or absence of the value. This pattern is common in data validation, search functionalities, and any context where you need to check for specific items in a collection. If you need to check for the existence of a key in a Map, you can use the has method of the Map object, like this: map.has(key).', 'purpose' => 'Test for value in array.' ],
        [ 'code' => 'let arrFind = arr.find(x => x === 2);', 'description' => 'This line finds the first element in the array arr that is strictly equal to 2 using the find method and an arrow function as the predicate. The find method returns the value of the first element that satisfies the provided testing function, or undefined if no elements satisfy the test. This operation is useful for searching arrays, validating data, or implementing features like "autocomplete", where you need to find a matching value. By storing the result in a variable, you can easily use the found value in your code for further processing, display, or any logic that depends on the search result. This pattern is common in data validation, search functionalities, and any context where you need to find specific items in a collection. If you need to find all elements that match a certain condition, you can use the filter method instead, like this: arr.filter(x => x === 2).', 'purpose' => 'Find element in array.' ],
        [ 'code' => 'let arrFindIndex = arr.findIndex(x => x === 2);', 'description' => 'This line finds the index of the first element in the array arr that is strictly equal to 2 using the findIndex method and an arrow function as the predicate. The findIndex method returns the index of the element if found, or -1 if the element is not present in the array. This operation is useful for searching elements in an array, validating data, or implementing features like "autocomplete", where you need to find a matching value. By storing the result in a variable, you can easily use the found index in your code for further processing, display, or any logic that depends on the search result. This pattern is common in data validation, search functionalities, and any context where you need to find specific items in a collection. If you need to find all elements that match a certain condition, you can use the filter method instead, like this: arr.filter(x => x === 2).', 'purpose' => 'Find index in array.' ],
        [ 'code' => 'let arrLastIndex = arr.lastIndexOf(2);', 'description' => 'This line finds the last index of the value 2 in the array arr using the lastIndexOf method and assigns the result to a variable named arrLastIndex. The lastIndexOf method returns the index of the last occurrence of a specified value in an array, or -1 if the value is not present. This operation is useful for searching elements in an array, validating data, or implementing features like "autocomplete", where you need to find the last matching value. By storing the result in a variable, you can easily use the found index in your code for further processing, display, or any logic that depends on the search result. This pattern is common in data validation, search functionalities, and any context where you need to find specific items in a collection. If you need to find all elements that match a certain condition, you can use the filter method instead, like this: arr.filter(x => x === 2).', 'purpose' => 'Find last occurrence.' ],
        [ 'code' => 'let arrToString = arr.toString();', 'description' => 'This line converts the array arr to a string using the toString method and assigns the result to a variable named arrToString. The toString method returns a string representing the specified array and its elements. This operation is useful for displaying arrays as strings, logging, or any scenario where you need a string representation of an array. By storing the result in a variable, you can use the stringified array in further processing, display, or any logic that depends on the string content. This pattern is common in data processing, debugging, and any context where you need to work with array data as strings. If you need to customize the string representation of an array, you can use the join method instead, like this: arr.join(", ").', 'purpose' => 'Stringify an array.' ],
        [ 'code' => 'let arrIsArray = Array.isArray(arr);', 'description' => 'This line checks if the variable arr is an array using the Array.isArray method and assigns the result (true or false) to a variable named arrIsArray. The Array.isArray method is the standard way to determine if a value is an array in JavaScript, as arrays are a special type of object. Knowing whether a variable is an array is important for validating data, controlling program flow, or applying array-specific methods and properties. By storing the result in a variable, you can easily use it in your code to handle arrays and non-arrays differently if needed. This is especially useful in functions or methods that can receive different types of arguments. If you need to check if a value is an object (including arrays, but also null and other objects), you can use the typeof operator, like this: typeof value === "object".', 'purpose' => 'Test for array type.' ],
        [ 'code' => 'let arrEvery = arr.every(x => x > 0);', 'description' => 'This line checks if all elements in the array arr are greater than 0 using the every method and an arrow function as the predicate. The every method tests whether all elements in the array pass the test implemented by the provided function, returning true or false as appropriate. This operation is useful for validating data, implementing features like "age verification", or any scenario where you need to ensure all items meet certain criteria. By storing the result in a variable, you can easily use the boolean result in your code to control flow or trigger actions based on the uniformity of the elements. This pattern is common in data validation, conditional logic, and any context where you need to check that all items in a collection satisfy specific conditions. If you need to check if at least one element matches a certain condition, you can use the some method instead, like this: arr.some(x => x > 0).', 'purpose' => 'Test all elements.' ],
        [ 'code' => 'let arrSome = arr.some(x => x > 0);', 'description' => 'This line checks if any element in the array arr is greater than 0 using the some method and an arrow function as the predicate. The some method tests whether at least one element in the array passes the test implemented by the provided function, returning true or false as appropriate. This operation is useful for validating data, implementing features like "favorites" or "bans", or any scenario where you need to check for the existence of at least one matching element. By storing the result in a variable, you can easily use the boolean result in your code to control flow or trigger actions based on the presence or absence of matching elements. This pattern is common in data validation, conditional logic, and any context where you need to check for specific items in a collection. If you need to check if all elements match a certain condition, you can use the every method instead, like this: arr.every(x => x > 0).', 'purpose' => 'Test if any element matches.' ],
        [ 'code' => 'let arrReduce = arr.reduce((a, b) => a + b, 0);', 'description' => 'This line applies the provided function against an accumulator and each element in the array arr (from left to right) to reduce it to a single value (in this case, the sum of all elements), and returns the single value. The reduce method is useful for aggregating data, such as calculating the total price of items in a cart, finding the maximum or minimum value in a list, or flattening an array of arrays. By storing the result in a variable, you can use the reduced value in further calculations, display it, or store it. This pattern is common in data processing, mathematical computations, and any context where you need to derive a single value from a collection of values. If you need to perform multiple operations on the array, consider using a forEach loop instead, which can be more flexible.', 'purpose' => 'Reduce array to value.' ],
        [ 'code' => 'let arrMap = arr.map(x => x * 2);', 'description' => 'This line creates a new array by applying the provided function to each element in the array arr, effectively doubling each element, and returns the new array. The map method is useful for transforming data, such as converting an array of temperatures in Celsius to Fahrenheit, or extracting a specific property from an array of objects. By storing the result in a variable, you can work with the new array independently of the original array. This pattern is common in data processing, API response handling, and any context where you need to transform or extract data from collections. Remember that map does not change the original array; it always returns a new array.', 'purpose' => 'Transform array.' ],
        [ 'code' => 'let arrFilter = arr.filter(x => x > 1);', 'description' => 'This line creates a new array with all elements in the array arr that pass the test implemented by the provided function, effectively filtering out elements that do not match the criteria (in this case, elements that are greater than 1), and returns the new array. The filter method is useful for selecting a subset of data, such as finding all users older than 18 in an array of user objects, or removing all null or undefined values from an array. By storing the result in a variable, you can work with the filtered array independently of the original array. This pattern is common in data processing, validation, and any context where you need to work with a subset of a collection. Note that filter does not change the original array; it always returns a new array.', 'purpose' => 'Filter array.' ],
        [ 'code' => 'let forEachResult = arr.forEach(x => console.log(x));', 'description' => 'This line executes the provided function once for each array element in the array arr, in ascending order, and returns undefined. The function is called with three arguments: the value of the element, the index of the element, and the array forEach was called upon. This method is useful for executing side effects at each element of an array, such as logging, updating a user interface, or modifying external variables. However, forEach is not chainable like other array methods (e.g., map, filter) because it returns undefined. If you need to transform data, consider using map instead, and if you need to filter data, use filter.', 'purpose' => 'Iterate array.' ],
        [ 'code' => 'let arrConcat = arr.concat([4,5]);', 'description' => 'This line concatenates the array arr with the array [4,5] into a new array using the concat method and assigns the result to a variable named arrConcat. The concat method is used to combine two or more arrays in JavaScript, returning a new array that contains all the elements from the joined arrays. This operation is useful for merging data, combining results, or building new arrays from existing ones. By storing the result in a variable, you can work with the combined array as a single entity, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, API response handling, and any context where you need to merge arrays. If you need to concatenate more than two arrays, you can pass them as additional arguments to the concat method, or use the spread operator: [...arr, ...[4,5]].', 'purpose' => 'Merge arrays.' ],
        [ 'code' => 'let arrReverse = arr.reverse();', 'description' => 'This line reverses the order of the elements in the array arr in place using the reverse method and assigns the result to a variable named arrReverse. The reverse method modifies the original array by reversing the order of its elements, so the first element becomes the last, and the last becomes the first. This operation is useful for tasks like undoing actions, displaying data in reverse order, or simply reversing a sequence. By storing the result in a variable, you can work with the reversed array, such as processing, displaying, or further manipulating the data. The length of the array remains the same, but the order of the elements is inverted. If you need to reverse a portion of an array, you can use the slice method to create a subarray and then reverse it, like this: arr.slice().reverse().', 'purpose' => 'Reverse array.' ],
        [ 'code' => 'let arrSort = arr.sort();', 'description' => 'This line sorts the elements of the array arr in ascending order using the sort method and assigns the result to a variable named arrSort. The sort method modifies the original array by sorting its elements according to the Unicode code points of the strings. This operation is useful for organizing data, making it easier to read, analyze, or process. By storing the result in a variable, you can work with the sorted array, such as displaying or further manipulating the data. The sort method accepts an optional compare function that you can use to customize the sort order, such as sorting numbers numerically or sorting strings by length. If the compare function is not provided, the elements are sorted as strings in ascending order.', 'purpose' => 'Sort array.' ],
        [ 'code' => 'let arrFill2 = arr.fill(1, 1, 3);', 'description' => 'This line fills the elements of the array arr from index 1 to index 3 (exclusive) with the value 1 using the fill method and assigns the result to a variable named arrFill2. The fill method changes all elements in an array to a static value, from a start index to an end index (defaulting to the entire array), and returns the modified array. This operation is useful for initializing or resetting specific portions of an array, such as when you want to create a subarray of ones, empty strings, or any other placeholder value. By storing the result in a variable, you can work with the partially filled array, such as processing, displaying, or further manipulating the data. This pattern is common in data initialization, configuration, and any context where you need to create arrays with default values. If you need to fill an array with values from another array or iterable, you can use the Array.from method in conjunction with the map method, like this: Array.from({length: 3}, (_, i) => i + 1).', 'purpose' => 'Partial fill array.' ],
        [ 'code' => 'let arrCopyWithin2 = arr.copyWithin(1, 0, 2);', 'description' => 'This line copies the values from the array arr starting at index 0 to the position starting at index 1, effectively overwriting the value at index 1 with the value at index 0, using the copyWithin method and assigns the result to a variable named arrCopyWithin2. The copyWithin method shallow copies part of an array to another location in the same array and returns it, without modifying its length. This operation is useful for moving or duplicating elements within the same array, such as when you want to reorder elements or create duplicates at different positions. By storing the result in a variable, you can work with the modified array, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, algorithm implementation, and any context where you need to work with array duplicates. If you need to copy elements between different arrays, you can use the Array.from method in conjunction with the map method, like this: Array.from(arr).map((v, i) => i >= 1 ? v : undefined).', 'purpose' => 'Copy within array.' ],
        [ 'code' => 'let arrFlat = [[1],[2]].flat();', 'description' => 'This line creates a new array with all sub-array elements concatenated into it recursively up to the specified depth (in this case, depth of 1) using the flat method and assigns the result to a variable named arrFlat. The flat method is useful for flattening nested arrays, such as when you have an array of arrays and you want to create a single-level array with all the values. By storing the result in a variable, you can work with the flattened array, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, API response handling, and any context where you need to work with nested collections. If you need to flatten an array with unknown depth, you can pass Infinity as the depth argument, like this: arr.flat(Infinity).', 'purpose' => 'Flatten array.' ],
        [ 'code' => 'let arrFlatMap = arr.flatMap(x => [x, x*2]);', 'description' => 'This line first maps each element in the array arr to a new array (in this case, an array containing the element and its double) using the map method, and then flattens the result into a new array with all sub-array elements concatenated into it recursively up to the specified depth (in this case, depth of 1) using the flat method. The flatMap method is useful for combining map and flatten operations into one, such as when you want to transform data and reduce the nesting of arrays in a single step. By storing the result in a variable, you can work with the flattened and mapped array, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, API response handling, and any context where you need to transform and flatten data simultaneously. If you need to perform more complex transformations or flattening with different depths, you can use the map and flat methods separately, like this: arr.map(x => [x, x*2]).flat().', 'purpose' => 'FlatMap array.' ],
        [ 'code' => 'let symbol = Symbol("id");', 'description' => 'This line creates a new unique symbol with the description "id" using the Symbol function and assigns it to a variable named symbol. Symbols are a new primitive data type introduced in ES6 that are immutable and can be used as unique object keys. This operation is useful for creating unique identifiers for object properties, such as when you want to avoid name clashes between properties or when you need a unique value that no other code can accidentally overwrite. By storing the result in a variable, you can use the symbol as a key for object properties, such as obj[symbol] = "value". This pattern is common in library and framework development, where you need to create unique keys for internal use. Note that symbols are not visible in for...in loops and Object.keys, so they are not enumerable like regular object properties.', 'purpose' => 'Create a unique identifier.' ],
        [ 'code' => 'let set = new Set([1,2,2,3]);', 'description' => 'This line creates a new Set object from the array [1,2,2,3], which will automatically remove the duplicate value 2, using the Set constructor and assigns it to a variable named set. A Set is a built-in JavaScript object that lets you store unique values of any type, whether primitive values or object references. This operation is useful for storing values that must be unique, such as when you want to ensure that a list of items has no duplicates. By storing the result in a variable, you can work with the set of values, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, algorithm implementation, and any context where you need to work with unique values. If you need to create a Set from an existing array or iterable object, you can use the Set constructor, like this: new Set(iterable).', 'purpose' => 'Remove duplicates from array.' ],
        [ 'code' => 'let map = new Map([["a", 1], ["b", 2]]);', 'description' => 'This line creates a new Map object from the array of key-value pairs [["a", 1], ["b", 2]] using the Map constructor and assigns it to a variable named map. A Map is a built-in JavaScript object that lets you store key-value pairs where the keys can be of any type, and remembers the original insertion order of the keys. This operation is useful for storing data that needs to be associated with specific keys, such as when you want to implement a dictionary, cache, or any associative array. By storing the result in a variable, you can work with the map of key-value pairs, such as processing, displaying, or further manipulating the data. This pattern is common in data processing, configuration management, and any context where you need to work with key-value pairs. If you need to create a Map from an existing object, you can use the Object.entries method in conjunction with the Map constructor, like this: new Map(Object.entries(obj)).', 'purpose' => 'Store key-value pairs.' ],
        [ 'code' => 'let arrFromSet = Array.from(set);', 'description' => 'This line creates a new array from the Set object set using the Array.from method and assigns it to a variable named arrFromSet. The Array.from method creates a new, shallow-copied Array instance from an array-like or iterable object. This operation is useful for converting Sets, Maps, or any iterable object to arrays. By storing the result in a variable, you can work with the array version of the data, such as processing, displaying, or further manipulating the data. This pattern is common in data manipulation, algorithm implementation, and any context where you need to work with array duplicates. Note that Array.from creates a shallow copy, so if the Set contains objects, the references to the objects are copied, not the objects themselves. To create a deep copy of an array, you can use other methods, such as JSON.parse(JSON.stringify(arr)).', 'purpose' => 'Convert Set to array.' ],
        [ 'code' => 'let arrFromMap = Array.from(map);', 'description' => 'This line creates a new array from the Map object map using the Array.from method and assigns it to a variable named arrFromMap. The Array.from method creates a new, shallow-copied Array instance from an array-like or iterable object. This operation is useful for converting Maps, Sets, or any iterable object to arrays. By storing the result in a variable, you can work with the array version of the data, such as processing, displaying, or further manipulating the data. This pattern is common in data manipulation, algorithm implementation, and any context where you need to work with array duplicates. Note that Array.from creates a shallow copy, so if the Map contains objects, the references to the objects are copied, not the objects themselves. To create a deep copy of an array, you can use other methods, such as JSON.parse(JSON.stringify(arr)).', 'purpose' => 'Convert Map to array.' ],
        [ 'code' => 'const mapArray = arr.map(x => x * 2).filter(x => x > 5);', 'description' => 'This line first uses the map method to double each element in the array arr, creating a new array where every value is multiplied by two. Then, it applies the filter method to keep only those values that are greater than 5. This combination is useful for transforming data and then selecting a subset based on a condition, which is a common pattern in data processing, analytics, and functional programming. The result is a new array containing only the doubled values that meet the specified criteria, making it easy to chain multiple operations for concise and readable code.', 'purpose' => 'Transform and filter arrays.' ],
        [ 'code' => 'try { someFunction(); } catch(err) { console.error(err); }', 'description' => 'This code demonstrates the use of a try-catch block in JavaScript. It attempts to call someFunction inside the try block. If an error occurs during the execution of someFunction, the catch block is triggered, and the error object err is passed to it. The catch block then logs the error to the console using console.error. This pattern is essential for handling exceptions gracefully, preventing the program from crashing, and providing useful debugging information. It is widely used in asynchronous code, API calls, and any situation where errors might occur.', 'purpose' => 'Handle errors gracefully.' ],
        [ 'code' => 'const { name, age } = user; console.log(name, age);', 'description' => 'This code uses object destructuring to extract the properties name and age from the user object and assigns them to variables with the same names. It then logs both variables to the console. Object destructuring is a concise way to access multiple properties from an object, improving code readability and reducing repetition. This technique is especially useful when working with API responses or large objects, allowing you to quickly access and use specific data fields in your application.', 'purpose' => 'Extract and use object properties.' ],
        [ 'code' => 'class Animal { constructor(name) { this.name = name; } }', 'description' => 'This code defines a class named Animal in JavaScript, which serves as a blueprint for creating objects with similar properties and methods. The constructor function takes a parameter name and assigns it to the instance property this.name. Classes are a modern way to implement object-oriented programming in JavaScript, making it easier to create and manage complex data structures, encapsulate behavior, and promote code reuse. This pattern is commonly used for modeling real-world entities and building scalable applications.', 'purpose' => 'Create object blueprints.' ],
        [ 'code' => 'const promise = new Promise((resolve, reject) => {});', 'description' => 'This line creates a new Promise object in JavaScript, which is used to handle asynchronous operations. The Promise constructor takes a function with two parameters: resolve and reject. You can call resolve to indicate successful completion or reject to signal an error. Promises provide a cleaner alternative to callbacks for managing asynchronous code, making it easier to chain operations, handle errors, and write more readable and maintainable code. They are widely used in modern JavaScript for tasks like API requests, file operations, and timers.', 'purpose' => 'Handle asynchronous operations.' ],
        [ 'code' => 'setTimeout(() => { console.log("executed"); }, 1000);', 'description' => 'This code uses the setTimeout function to schedule the execution of a callback function after a specified delay. In this example, the callback logs the string "executed" to the console after 1000 milliseconds (1 second). setTimeout is commonly used to delay actions, create simple timers, or defer code execution until a later time. It is useful for animations, user notifications, and simulating asynchronous behavior in JavaScript applications.', 'purpose' => 'Delay code execution.' ],
        [ 'code' => 'const regex = /[a-z]+/g; const matches = str.match(regex);', 'description' => 'This code defines a regular expression regex that matches one or more consecutive lowercase letters in a string. It then uses the match method on the string str to find all substrings that match this pattern, storing the results in the matches array. Regular expressions are powerful tools for pattern matching and text processing, allowing you to extract, validate, or manipulate specific parts of strings efficiently. This approach is widely used in data validation, search, and text analysis tasks.', 'purpose' => 'Extract patterns from text.' ],
        [ 'code' => 'const spread = [...array1, ...array2];', 'description' => 'This line uses the spread operator (...) to combine the elements of array1 and array2 into a new array called spread. The spread operator expands the contents of each array, allowing you to merge multiple arrays or add elements in a concise and readable way. This technique is useful for copying, concatenating, or restructuring arrays, and is commonly used in modern JavaScript for data manipulation, function arguments, and state management in frameworks like React.', 'purpose' => 'Merge arrays.' ],
        [ 'code' => 'Object.keys(obj).forEach(key => console.log(key));', 'description' => 'This code retrieves all the enumerable property names (keys) of the object obj using Object.keys, which returns an array of keys. It then iterates over each key using the forEach method and logs each key to the console. This pattern is useful for inspecting, processing, or displaying the properties of an object, and is commonly used in debugging, data transformation, and dynamic property handling in JavaScript applications.', 'purpose' => 'Iterate object properties.' ],
        // 11-100 (new medium examples)
        [ 'code' => 'const unique = arr => [...new Set(arr)];', 'description' => "This function takes an array arr and returns a new array containing only the unique values from the original array. It does this by creating a Set from arr, which automatically removes any duplicate values because Sets only allow unique elements. The spread operator [...] then converts the Set back into an array. This is a concise and efficient way to deduplicate arrays in JavaScript, especially useful when you want to ensure that your data set contains only one instance of each value, such as when processing user input, filtering results, or preparing data for further analysis.", 'purpose' => 'Get unique array values.' ],
        [ 'code' => 'const sum = arr.reduce((a, b) => a + b, 0);', 'description' => "This code calculates the sum of all elements in the array arr by using the reduce method. The reduce function iterates through each element, accumulating the total by adding each value to the accumulator a, starting from 0. This is a common pattern for aggregating values in an array, such as calculating totals, averages, or other summary statistics. It is especially useful in data analysis, financial calculations, and any scenario where you need to combine multiple values into a single result.", 'purpose' => 'Aggregate array values.' ],
        [ 'code' => 'const reversed = str.split("").reverse().join("");', 'description' => "This code reverses a string by first splitting it into an array of characters using split(\\\"\\\"). It then reverses the order of the array elements with reverse(), and finally joins the characters back together into a string with join(\\\"\\\"). This technique is useful for tasks such as checking for palindromes, formatting output, or manipulating text in games and applications. It demonstrates how array methods can be combined to perform complex string operations in a concise and readable way.", 'purpose' => 'Manipulate strings.' ],
        [ 'code' => 'const isEven = n => n % 2 === 0;', 'description' => "This function checks if a given number n is even by using the modulo operator (%). If n divided by 2 has a remainder of 0, the function returns true, indicating that n is even. Otherwise, it returns false. This is a fundamental check in programming, often used in loops, conditional logic, and algorithms that need to distinguish between even and odd numbers, such as distributing tasks, alternating behaviors, or validating input.", 'purpose' => 'Test number parity.' ],
        [ 'code' => 'const capitalize = s => s.charAt(0).toUpperCase() + s.slice(1);', 'description' => "This function takes a string s and returns a new string with the first character converted to uppercase and the rest of the string unchanged. It uses charAt(0) to get the first character, toUpperCase() to capitalize it, and slice(1) to get the remainder of the string. This is commonly used for formatting names, titles, or any text that should start with a capital letter, improving readability and adhering to style conventions.", 'purpose' => 'Format strings.' ],
        [ 'code' => 'const flatten = arr => arr.flat(Infinity);', 'description' => "This function takes an array arr and flattens it to a single level, regardless of how deeply nested the original array is. It uses the flat method with Infinity as the argument, which tells JavaScript to recursively flatten all sub-arrays into one array. This is especially useful when working with data that may have unpredictable or variable levels of nesting, such as API responses, user-generated content, or complex data structures. By flattening the array, you can simplify processing, searching, or displaying the data, making it easier to work with in your application.", 'purpose' => 'Flatten arrays.' ],
        [ 'code' => 'const clone = obj => ({ ...obj });', 'description' => "This function creates a shallow copy of the object obj by using the spread operator (...). It copies all enumerable properties from the original object into a new object, but does not clone nested objects or arrays. This is useful for duplicating objects when you want to make changes without affecting the original, such as in state management, undo features, or when working with immutable data patterns. However, be aware that changes to nested objects will still affect the original, since only the top-level properties are copied.", 'purpose' => 'Copy objects.' ],
        [ 'code' => 'const merge = (a, b) => ({ ...a, ...b });', 'description' => "This function merges two objects, a and b, into a new object by using the spread operator for both. Properties from object b will overwrite those from object a if they share the same key. This is a common pattern for combining configuration options, updating state, or merging data from different sources. It is important to note that this is a shallow merge, so nested objects are not deeply merged. For deep merging, a custom function or library is needed.", 'purpose' => 'Combine objects.' ],
        [ 'code' => 'const delay = ms => new Promise(res => setTimeout(res, ms));', 'description' => "This function returns a Promise that resolves after a specified number of milliseconds (ms). It uses setTimeout to create the delay, and the Promise allows you to use async/await syntax for pausing execution in asynchronous code. This is useful for creating artificial delays, rate-limiting actions, waiting for animations, or simulating network latency in tests. By returning a Promise, it integrates smoothly with modern JavaScript asynchronous patterns.", 'purpose' => 'Create delays in async code.' ],
        [ 'code' => 'const arr = Array.from({length: 5}, (_, i) => i);', 'description' => "This code creates a new array of length 5, where each element is initialized to its index value (0 through 4). It uses Array.from with an object specifying the desired length and a mapping function that returns the index for each element. This is a concise way to generate arrays of sequential numbers, which is useful for loops, pagination, test data, or any scenario where you need a range of values. The resulting array is [0, 1, 2, 3, 4].", 'purpose' => 'Generate arrays.' ],
        [ 'code' => 'const swap = (arr, i, j) => { [arr[i], arr[j]] = [arr[j], arr[i]]; };', 'description' => 'This function swaps the elements at indices i and j in the array arr by using array destructuring assignment. Swapping elements is a common operation in algorithms such as sorting, shuffling, or when you need to exchange the positions of two items in a list. By using destructuring, the swap is performed in a single, concise line without needing a temporary variable, making the code more readable and efficient. This approach is especially useful in in-place algorithms where memory usage should be minimized, and it helps maintain the integrity of the original array structure while only changing the positions of the specified elements.', 'purpose' => 'Manipulate arrays.' ],
        [ 'code' => 'const getRandom = arr => arr[Math.floor(Math.random() * arr.length)];', 'description' => 'This function selects a random element from the array arr by generating a random index using Math.random, multiplying it by the array length, and rounding down with Math.floor. This is a common technique for random selection in games, sampling, or shuffling data. It ensures that every element in the array has an equal chance of being chosen, making it useful for scenarios like picking a random winner, selecting a random question, or simulating randomness in algorithms. The function is concise and leverages JavaScript’s built-in math functions for efficient and reliable random access.', 'purpose' => 'Random selection.' ],
        [ 'code' => 'const chunk = (arr, size) => Array.from({length: Math.ceil(arr.length / size)}, (_, i) => arr.slice(i * size, i * size + size));', 'description' => 'This function splits the array arr into smaller arrays (chunks) of the specified size. It uses Array.from to create the correct number of chunks, and for each chunk, it slices the original array to get the appropriate segment. Chunking is useful for processing large datasets in manageable pieces, paginating results, or batching operations. This approach ensures that the last chunk may be smaller if the array length is not a multiple of the chunk size. It is commonly used in data processing, UI rendering, and any scenario where you need to divide data into groups for easier handling or display.', 'purpose' => 'Chunk arrays.' ],
        [ 'code' => 'const range = (start, end) => Array.from({length: end - start}, (_, i) => start + i);', 'description' => 'This function generates an array of sequential numbers starting from the value start up to, but not including, end. It uses Array.from to create an array of the required length, and the mapping function fills each position with the correct value. This is useful for creating ranges for iteration, pagination, test data, or any scenario where you need a list of consecutive numbers. The resulting array is flexible and can be used in loops, data processing, or as input for other functions that require a range of values.', 'purpose' => 'Generate ranges.' ],
        [ 'code' => 'const groupBy = (arr, fn) => arr.reduce((acc, x) => { (acc[fn(x)] ||= []).push(x); return acc; }, {});', 'description' => 'This function groups the elements of the array arr based on the result of applying the function fn to each element. It uses reduce to build an object where each key is the result of fn(x), and the value is an array of elements that share that key. This is useful for categorizing data, organizing items by property, or preparing data for grouped display. It is commonly used in data analysis, reporting, and any scenario where you need to cluster items by a specific criterion.', 'purpose' => 'Group array elements.' ],
        [ 'code' => 'const zip = (a, b) => a.map((k, i) => [k, b[i]]);', 'description' => 'This function combines two arrays, a and b, into a single array of pairs, where each pair consists of elements from the same index in both arrays. It uses map to iterate over array a and pairs each element with the corresponding element in b. This is useful for merging related data, creating tuples, or synchronizing parallel arrays. It is commonly used in data processing, matrix operations, and any scenario where you need to work with paired values from two sources.', 'purpose' => 'Pair array elements.' ],
        [ 'code' => 'const debounce = (fn, ms) => { let last = 0; return (...a) => { const now = Date.now(); if (now - last > ms) { last = now; fn(...a); } }; };', 'description' => 'This function limits how often the provided function fn can be called by ensuring it only executes if a certain amount of time (ms) has passed since the last call. It uses a timestamp to track the last execution and only allows the function to run if the interval has elapsed. This is useful for rate-limiting actions like handling scroll or resize events, preventing excessive API calls, or improving performance in user interfaces by reducing the frequency of expensive operations.', 'purpose' => 'Limit function frequency.' ],
        [ 'code' => 'const once = fn => { let called = false; return (...a) => { if (!called) { called = true; fn(...a); } }; };', 'description' => 'This function ensures that the provided function fn can only be executed a single time. It uses a flag called to track whether fn has already been called, and if so, it prevents further executions. This is useful for initialization routines, event handlers, or any scenario where an action should only occur once, such as setting up listeners, loading resources, or triggering one-time effects in an application.', 'purpose' => 'Single-use functions.' ],
        [ 'code' => 'const curry = fn => (...a) => a.length >= fn.length ? fn(...a) : (...b) => curry(fn)(...a, ...b);', 'description' => 'Curry a function.', 'purpose' => 'Partial application.' ],
        [ 'code' => 'const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);', 'description' => 'This function creates a new function by composing multiple functions from right to left. When the composed function is called, it passes the input through each function in the sequence, starting from the last and moving to the first. This is useful for building complex operations from simple, reusable functions, improving code modularity, and enabling elegant data transformations. Function composition is a key concept in functional programming and helps keep code concise and maintainable.', 'purpose' => 'Function composition.' ],
        [ 'code' => 'const pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);', 'description' => 'This function creates a new function by piping multiple functions from left to right. When the piped function is called, it passes the input through each function in the sequence, starting from the first and moving to the last. This is useful for chaining operations, building data processing pipelines, and improving code readability. Piping is a common pattern in functional programming, making it easier to follow the flow of data through a series of transformations.', 'purpose' => 'Function pipelining.' ],
        [ 'code' => 'const memoize = fn => { const c = {}; return (...a) => c[a] || (c[a] = fn(...a)); };', 'description' => 'This function returns a memoized version of the provided function fn, caching the results of previous calls based on their arguments. When the memoized function is called with the same arguments again, it returns the cached result instead of recomputing it. This is useful for optimizing expensive computations, improving performance, and reducing redundant processing in scenarios like recursive algorithms, data fetching, or calculations that are called repeatedly with the same inputs.', 'purpose' => 'Cache function results.' ],
        [ 'code' => 'const isPalindrome = s => s === s.split("").reverse().join("");', 'description' => 'This function checks whether the string s is a palindrome by reversing the string and comparing it to the original. If both are equal, the function returns true, indicating that the string reads the same forwards and backwards. This is useful for validating palindromic words or phrases, solving puzzles, or implementing features in games and text analysis tools. Palindrome checks are common in coding challenges and interview questions.', 'purpose' => 'String analysis.' ],
        [ 'code' => 'const isPrime = n => { for(let i=2;i<=Math.sqrt(n);i++) if(n%i===0)return false; return n>1; };', 'description' => 'This function determines if the number n is a prime by checking divisibility from 2 up to the square root of n. If any divisor is found, it returns false; otherwise, it returns true for numbers greater than 1. Prime checking is fundamental in mathematics, cryptography, and algorithms, and is often used in coding interviews, number theory problems, and applications that require prime validation or generation.', 'purpose' => 'Number theory.' ],
        [ 'code' => 'const factorial = n => n <= 1 ? 1 : n * factorial(n - 1);', 'description' => 'This function calculates the factorial of n recursively. If n is less than or equal to 1, it returns 1; otherwise, it multiplies n by the factorial of n minus one. Factorials are widely used in mathematics, statistics, and combinatorics for counting arrangements, permutations, and probabilities. Recursive factorial functions are a classic example in programming education and algorithm design.', 'purpose' => 'Recursion.' ],
        [ 'code' => 'const gcd = (a, b) => b ? gcd(b, a % b) : a;', 'description' => 'This function computes the greatest common divisor (GCD) of two numbers a and b using the Euclidean algorithm. It recursively calls itself with b and the remainder of a divided by b until b is zero, at which point a is the GCD. GCD calculations are essential in mathematics, cryptography, and simplifying fractions, and are a common topic in algorithm design and coding interviews.', 'purpose' => 'Math algorithms.' ],
        [ 'code' => 'const lcm = (a, b) => a * b / gcd(a, b);', 'description' => 'This function calculates the least common multiple (LCM) of two numbers a and b by multiplying them together and dividing by their greatest common divisor (GCD). LCM is useful for finding common denominators, scheduling, and solving problems involving multiples. It is widely used in mathematics, computer science, and real-world applications that require synchronization or alignment of cycles.', 'purpose' => 'Math algorithms.' ],
        [ 'code' => 'const shuffle = arr => arr.sort(() => Math.random() - 0.5);', 'description' => 'This function shuffles the elements of the array arr in random order by sorting the array with a comparator that returns a random value. While this method is simple and concise, it does not guarantee a perfectly uniform shuffle. Shuffling is useful in games, simulations, and scenarios where random ordering is needed, such as drawing cards, randomizing questions, or creating unpredictable sequences.', 'purpose' => 'Randomize arrays.' ],
        [ 'code' => 'const hexToRgb = hex => hex.length === 4 ? hex.match(/\w/g).slice(1).map(x=>parseInt(x+x,16)) : hex.match(/\w\w/g).slice(1).map(x=>parseInt(x,16));', 'description' => 'This function converts a hexadecimal color string (hex) to its corresponding RGB values. It handles both shorthand (e.g., #abc) and full (e.g., #aabbcc) hex formats by parsing the string and converting each color component to a decimal value. This is useful for color manipulation, theming, or converting user input into a format suitable for CSS or graphics programming. Accurate color conversion is essential in web development and design tools.', 'purpose' => 'Color conversion.' ],
        [ 'code' => 'const rgbToHex = (r,g,b) => "#"+[r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");', 'description' => 'This function converts red, green, and blue (RGB) color values into a hexadecimal color string. It converts each component to a two-digit hexadecimal string and concatenates them with a leading #. This is useful for generating CSS color codes, saving color selections, or converting between color formats in design and graphics applications. RGB to hex conversion is a common requirement in web development and digital art tools.', 'purpose' => 'Color conversion.' ],
        [ 'code' => 'const getQueryParam = (url, key) => new URL(url).searchParams.get(key);', 'description' => 'This function extracts the value of a specific query parameter (key) from a given URL string. It creates a URL object and uses the searchParams API to retrieve the parameter value. This is useful for parsing URLs, handling user input, or processing API requests where parameters are passed in the query string. Query parameter extraction is essential in web development, routing, and analytics.', 'purpose' => 'URL parsing.' ],
        [ 'code' => 'const uniqueBy = (arr, fn) => Array.from(new Map(arr.map(x => [fn(x), x])).values());', 'description' => 'Get unique array values by a function.', 'purpose' => 'Array deduplication.' ],
        [ 'code' => 'const deepClone = obj => JSON.parse(JSON.stringify(obj));', 'description' => 'Deep clone an object.', 'purpose' => 'Copy nested objects.' ],
        [ 'code' => 'const getType = v => Object.prototype.toString.call(v).slice(8, -1);', 'description' => 'Get the type of a value.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isObject = v => v && typeof v === "object" && !Array.isArray(v);', 'description' => 'Check if v is a plain object.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isArray = Array.isArray;', 'description' => 'Check if a value is an array.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isFunction = v => typeof v === "function";', 'description' => 'Check if v is a function.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isString = v => typeof v === "string";', 'description' => 'Check if v is a string.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isNumber = v => typeof v === "number";', 'description' => 'Check if v is a number.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isBoolean = v => typeof v === "boolean";', 'description' => 'Check if v is a boolean.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isNull = v => v === null;', 'description' => 'Check if v is null.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isUndefined = v => v === undefined;', 'description' => 'Check if v is undefined.', 'purpose' => 'Type checking.' ],
        [ 'code' => 'const isEmpty = v => v == null || (Array.isArray(v) || typeof v === "string") && v.length === 0;', 'description' => 'Check if v is empty.', 'purpose' => 'Check for emptiness.' ],
        [ 'code' => 'const compact = arr => arr.filter(Boolean);', 'description' => 'Remove falsy values from arr.', 'purpose' => 'Clean arrays.' ],
        [ 'code' => 'const pluck = (arr, key) => arr.map(x => x[key]);', 'description' => 'Extract a property from each object in arr.', 'purpose' => 'Extract object properties.' ],
        [ 'code' => 'const pick = (obj, keys) => keys.reduce((acc, k) => (acc[k] = obj[k], acc), {});', 'description' => 'Pick specific keys from obj.', 'purpose' => 'Select object properties.' ],
        [ 'code' => 'const omit = (obj, keys) => Object.fromEntries(Object.entries(obj).filter(([k]) => !keys.includes(k)));', 'description' => 'Omit specific keys from obj.', 'purpose' => 'Remove object properties.' ],
        [ 'code' => 'const invert = obj => Object.fromEntries(Object.entries(obj).map(([k, v]) => [v, k]));', 'description' => 'Invert keys and values of obj.', 'purpose' => 'Swap object keys/values.' ],
        [ 'code' => 'const countBy = (arr, fn) => arr.reduce((acc, x) => ((acc[fn(x)] = (acc[fn(x)] || 0) + 1), acc), {});', 'description' => 'Count elements in arr by a function.', 'purpose' => 'Count by group.' ],
        [ 'code' => 'const partition = (arr, fn) => arr.reduce((acc, x) => (acc[fn(x) ? 0 : 1].push(x), acc), [[], []]);', 'description' => 'Partition arr by a function.', 'purpose' => 'Split arrays by condition.' ],
        [ 'code' => 'const intersection = (a, b) => a.filter(x => b.includes(x));', 'description' => 'Find common elements in a and b.', 'purpose' => 'Array intersection.' ],
        [ 'code' => 'const difference = (a, b) => a.filter(x => !b.includes(x));', 'description' => 'Find elements in a not in b.', 'purpose' => 'Array difference.' ],
        [ 'code' => 'const union = (a, b) => [...new Set([...a, ...b])];', 'description' => 'Union of two arrays.', 'purpose' => 'Array union.' ],
        [ 'code' => 'const symmetricDifference = (a, b) => difference(union(a, b), intersection(a, b));', 'description' => 'Symmetric difference of arrays.', 'purpose' => 'Array symmetric difference.' ],
        [ 'code' => 'const toPairs = obj => Object.entries(obj);', 'description' => 'Convert obj to array of [key, value] pairs.', 'purpose' => 'Object to pairs.' ],
        [ 'code' => 'const fromPairs = arr => Object.fromEntries(arr);', 'description' => 'Convert array of pairs to object.', 'purpose' => 'Pairs to object.' ],
        [ 'code' => 'const clamp = (n, min, max) => Math.max(min, Math.min(n, max));', 'description' => 'Clamp n between min and max.', 'purpose' => 'Limit a value.' ],
        [ 'code' => 'const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;', 'description' => 'Get a random integer between min and max.', 'purpose' => 'Random integer.' ],
        [ 'code' => 'const pad = (n, w, z = "0") => n.toString().padStart(w, z);', 'description' => 'Pad a number with zeros.', 'purpose' => 'Pad numbers.' ],
        [ 'code' => 'const repeat = (str, n) => str.repeat(n);', 'description' => 'Repeat a string n times.', 'purpose' => 'Repeat strings.' ],
        [ 'code' => 'const escapeRegExp = s => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");', 'description' => 'Escape special regex characters in s.', 'purpose' => 'Escape regex.' ],
        [ 'code' => 'const unescapeHtml = s => s.replace(/&amp;/g, &quot;&amp;&quot;).replace(/&lt;/g, &quot;<&quot;).replace(/&gt;/g, &quot;>&quot;).replace(/&quot;/g, \"&quot;).replace(/&#39;/g, \'&quot;);', 'description' => 'Unescape HTML entities in s.', 'purpose' => 'Unescape HTML.' ],
        [ 'code' => 'const parseJSON = str => { try { return JSON.parse(str); } catch { return null; } };', 'description' => 'Safely parse JSON.', 'purpose' => 'Parse JSON with error handling.' ],
        [ 'code' => 'const stringify = obj => JSON.stringify(obj);', 'description' => 'Stringify an object.', 'purpose' => 'Convert object to JSON.' ],
        [ 'code' => 'const parseNumber = str => parseFloat(str) || 0;', 'description' => 'Parse a number from a string.', 'purpose' => 'String to number.' ],
        [ 'code' => 'const toArray = v => Array.isArray(v) ? v : [v];', 'description' => 'Convert v to an array if not already.', 'purpose' => 'Ensure array type.' ],
        [ 'code' => 'const toBoolean = v => !!v;', 'description' => 'Convert v to boolean.', 'purpose' => 'Ensure boolean type.' ],
        [ 'code' => 'const toNumber = v => +v;', 'description' => 'Convert v to number.', 'purpose' => 'Ensure number type.' ],
        [ 'code' => 'const toString = v => v + "";', 'description' => 'Convert v to string.', 'purpose' => 'Ensure string type.' ],
        [ 'code' => 'const noop = () => {};', 'description' => 'A function that does nothing.', 'purpose' => 'No-operation function.' ],
        [ 'code' => 'const identity = x => x;', 'description' => 'A function that returns its argument.', 'purpose' => 'Identity function.' ],
        [ 'code' => 'const times = (n, fn) => Array.from({length: n}, (_, i) => fn(i));', 'description' => 'Call fn n times.', 'purpose' => 'Repeat function calls.' ],
        [ 'code' => 'const sleep = ms => new Promise(res => setTimeout(res, ms));', 'description' => 'Pause execution for ms milliseconds.', 'purpose' => 'Delay in async code.' ],
        [ 'code' => 'const getLast = arr => arr[arr.length - 1];', 'description' => 'Get the last element of arr.', 'purpose' => 'Access array end.' ],
        [ 'code' => 'const getFirst = arr => arr[0];', 'description' => 'Get the first element of arr.', 'purpose' => 'Access array start.' ],
        [ 'code' => 'const remove = (arr, val) => arr.filter(x => x !== val);', 'description' => 'Remove val from arr.', 'purpose' => 'Remove array elements.' ],
        [ 'code' => 'const insert = (arr, idx, val) => [...arr.slice(0, idx), val, ...arr.slice(idx)];', 'description' => 'Insert val at idx in arr.', 'purpose' => 'Insert into array.' ],
        [ 'code' => 'const update = (arr, idx, val) => arr.map((x, i) => i === idx ? val : x);', 'description' => 'Update value at idx in arr.', 'purpose' => 'Update array elements.' ],
        [ 'code' => 'const sumBy = (arr, fn) => arr.reduce((acc, x) => acc + fn(x), 0);', 'description' => 'Sum array values by a function.', 'purpose' => 'Aggregate by property.' ],
        [ 'code' => 'const maxBy = (arr, fn) => arr.reduce((a, b) => fn(a) > fn(b) ? a : b);', 'description' => 'Find max element by a function.', 'purpose' => 'Find max by property.' ],
        [ 'code' => 'const minBy = (arr, fn) => arr.reduce((a, b) => fn(a) < fn(b) ? a : b);', 'description' => 'Find min element by a function.', 'purpose' => 'Find min by property.' ],
        [ 'code' => 'const pluckDeep = (arr, path) => arr.map(x => path.split(".").reduce((a, k) => a && a[k], x));', 'description' => 'Extract nested property from each object in arr.', 'purpose' => 'Deep property extraction.' ],
        [ 'code' => 'const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);', 'description' => 'Check if obj has own property key.', 'purpose' => 'Property existence check.' ],
        [ 'code' => 'const getNested = (obj, path) => path.split(".").reduce((a, k) => a && a[k], obj);', 'description' => 'Get nested property from obj.', 'purpose' => 'Access deep properties.' ],
        [ 'code' => 'const setNested = (obj, path, val) => { const keys = path.split("."); let o = obj; while (keys.length > 1) o = o[keys.shift()]; o[keys[0]] = val; };', 'description' => 'Set nested property in obj.', 'purpose' => 'Modify deep properties.' ],
        [ 'code' => 'const deleteNested = (obj, path) => { const keys = path.split("."); let o = obj; while (keys.length > 1) o = o[keys.shift()]; delete o[keys[0]]; };', 'description' => 'Delete nested property in obj.', 'purpose' => 'Remove deep properties.' ],
        [ 'code' => 'const toCamel = s => s.replace(/[-_](.)/g, (_, c) => c.toUpperCase());', 'description' => 'Convert string to camelCase.', 'purpose' => 'String case conversion.' ],
        [ 'code' => 'const toSnake = s => s.replace(/[A-Z]/g, c => "_" + c.toLowerCase());', 'description' => 'Convert string to snake_case.', 'purpose' => 'String case conversion.' ],
        [ 'code' => 'const toKebab = s => s.replace(/[A-Z]/g, c => "-" + c.toLowerCase());', 'description' => 'Convert string to kebab-case.', 'purpose' => 'String case conversion.' ],
        [ 'code' => 'const debounceAsync = (fn, ms) => { let t; return async (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };', 'description' => 'Debounce an async function.', 'purpose' => 'Limit async calls.' ],
        [ 'code' => 'const throttleAsync = (fn, ms) => { let last = 0; return async (...a) => { const now = Date.now(); if (now - last > ms) { last = now; await fn(...a); } }; };', 'description' => 'Throttle an async function.', 'purpose' => 'Limit async frequency.' ],
        [ 'code' => 'const isDeepEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);', 'description' => 'Check deep equality of two values.', 'purpose' => 'Deep comparison.' ],
        [ 'code' => 'const getEnv = key => process.env[key];', 'description' => 'Get an environment variable.', 'purpose' => 'Access environment.' ],
        [ 'code' => 'const parseCSV = str => str.split("\\n").map(row => row.split(","));', 'description' => 'Parse CSV string to array.', 'purpose' => 'CSV parsing.' ],
        [ 'code' => 'const toCSV = arr => arr.map(row => row.join(",")).join("\\n");', 'description' => 'Convert array to CSV string.', 'purpose' => 'CSV formatting.' ],
        [ 'code' => 'const proxy = new Proxy(target, { get: (target, prop) => target[prop] ?? "default" });', 'description' => 'Proxy for custom object access.', 'purpose' => 'Intercept object operations.' ],
        [ 'code' => 'const streamData = fs.createReadStream("file.txt").pipe(transform).pipe(process.stdout);', 'description' => 'Stream and transform file data.', 'purpose' => 'Efficient data processing.' ],
        [ 'code' => 'const tree = { value: 1, left: { value: 2 }, right: { value: 3 } };', 'description' => 'Tree data structure.', 'purpose' => 'Hierarchical data.' ],
        [ 'code' => 'const fibonacci = (n) => n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);', 'description' => 'Recursive Fibonacci function.', 'purpose' => 'Recursion example.' ],
        [ 'code' => 'const evaluate = (expr) => new Function("return " + expr)();', 'description' => 'Evaluate a string as code.', 'purpose' => 'Dynamic code execution.' ],
        // 11-100 (new hard examples)
        [ 'code' => 'const flattenDeep = arr => arr.reduce((a, v) => a.concat(Array.isArray(v) ? flattenDeep(v) : v), []);', 'description' => 'Recursively flatten an array.', 'purpose' => 'Deep array flattening.' ],
        [ 'code' => 'const quickSort = arr => arr.length < 2 ? arr : [...quickSort(arr.filter(x => x < arr[0])), arr[0], ...quickSort(arr.filter(x => x > arr[0]))];', 'description' => 'Quick sort implementation.', 'purpose' => 'Sorting algorithm.' ],
        [ 'code' => 'const curry = fn => (...a) => a.length >= fn.length ? fn(...a) : (...b) => curry(fn)(...a, ...b);', 'description' => 'This function transforms a function fn into its curried version, allowing you to call it with fewer arguments than it expects and receive a new function that takes the remaining arguments. Currying is useful for creating reusable, partially-applied functions, improving code modularity, and enabling more flexible function composition. It is a common pattern in functional programming and helps simplify complex operations by breaking them into smaller, composable steps.', 'purpose' => 'Partial application.' ],
        [ 'code' => 'const throttle = (fn, ms) => { let last = 0; return (...a) => { const now = Date.now(); if (now - last > ms) { last = now; fn(...a); } }; };', 'description' => 'Throttle a function.', 'purpose' => 'Limit function frequency.' ],
        [ 'code' => 'const deepFreeze = obj => { Object.getOwnPropertyNames(obj).forEach(prop => { if (typeof obj[prop] === "object" && obj[prop] !== null) deepFreeze(obj[prop]); }); return Object.freeze(obj); };', 'description' => 'Recursively freeze an object.', 'purpose' => 'Immutable objects.' ],
        [ 'code' => 'const eventEmitter = () => { const events = {}; return { on: (e, fn) => (events[e] = events[e] || []).push(fn), emit: (e, ...a) => (events[e] || []).forEach(fn => fn(...a)) }; };', 'description' => 'Simple event emitter.', 'purpose' => 'Event-driven programming.' ],
        [ 'code' => 'const LRUCache = function(capacity) { this.cache = new Map(); this.capacity = capacity; }; LRUCache.prototype.get = function(key) { if (!this.cache.has(key)) return -1; const v = this.cache.get(key); this.cache.delete(key); this.cache.set(key, v); return v; }; LRUCache.prototype.put = function(key, value) { if (this.cache.has(key)) this.cache.delete(key); this.cache.set(key, value); if (this.cache.size > this.capacity) this.cache.delete(this.cache.keys().next().value); };', 'description' => 'LRU Cache class.', 'purpose' => 'Cache with eviction policy.' ],
        [ 'code' => 'const binarySearch = (arr, t) => { let l=0, r=arr.length-1; while(l<=r){const m=Math.floor((l+r)/2);if(arr[m]===t)return m;arr[m]<t?l=m+1:r=m-1;}return -1; };', 'description' => 'Binary search algorithm.', 'purpose' => 'Efficient search.' ],
        [ 'code' => 'const mergeSort = arr => { if (arr.length < 2) return arr; const m = Math.floor(arr.length / 2); const l = mergeSort(arr.slice(0, m)); const r = mergeSort(arr.slice(m)); const merge = (a, b) => a.length === 0 ? b : b.length === 0 ? a : a[0] < b[0] ? [a[0], ...merge(a.slice(1), b)] : [b[0], ...merge(a, b.slice(1))]; return merge(l, r); };', 'description' => 'Merge sort implementation.', 'purpose' => 'Sorting algorithm.' ],
        [ 'code' => 'const asyncMap = async (arr, fn) => Promise.all(arr.map(fn));', 'description' => 'Async map over array.', 'purpose' => 'Parallel async operations.' ],
        [ 'code' => 'const retry = (fn, retries = 3) => fn().catch(err => retries > 1 ? retry(fn, retries - 1) : Promise.reject(err));', 'description' => 'Retry a promise-returning function.', 'purpose' => 'Resilient async code.' ],
        [ 'code' => 'const withTimeout = (promise, ms) => Promise.race([promise, new Promise((_, rej) => setTimeout(() => rej(new Error("Timeout")), ms))]);', 'description' => 'Promise with timeout.', 'purpose' => 'Timeout async operations.' ],
        [ 'code' => 'const pipeline = (...fns) => x => fns.reduce((v, f) => f(v), x);', 'description' => 'Pipeline of functions.', 'purpose' => 'Function pipelining.' ],
        [ 'code' => 'const flattenObject = obj => Object.keys(obj).reduce((acc, k) => { if (typeof obj[k] === "object" && obj[k] !== null) { const flat = flattenObject(obj[k]); Object.keys(flat).forEach(fk => acc[k + "." + fk] = flat[fk]); } else acc[k] = obj[k]; return acc; }, {});', 'description' => 'Flatten nested object.', 'purpose' => 'Object flattening.' ],
        [ 'code' => 'const unflattenObject = obj => { const result = {}; for (const k in obj) { const keys = k.split("."); keys.reduce((acc, key, i) => acc[key] = i === keys.length - 1 ? obj[k] : acc[key] || {}, result); } return result; };', 'description' => 'Unflatten object.', 'purpose' => 'Restore nested structure.' ],
        [ 'code' => 'const deepEqual = (a, b) => { if (a === b) return true; if (typeof a !== typeof b) return false; if (typeof a !== "object" || a === null || b === null) return false; const ak = Object.keys(a), bk = Object.keys(b); if (ak.length !== bk.length) return false; return ak.every(k => deepEqual(a[k], b[k])); };', 'description' => 'Deep equality check.', 'purpose' => 'Compare complex objects.' ],
        [ 'code' => 'const shuffle = arr => { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; };', 'description' => 'Fisher-Yates shuffle.', 'purpose' => 'Randomize array order.' ],
        [ 'code' => 'const uuidv4 = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => { const r = Math.random() * 16 | 0, v = c === "x" ? r : (r & 0x3 | 0x8); return v.toString(16); });', 'description' => 'Generate a UUID v4.', 'purpose' => 'Unique identifiers.' ],
        [ 'code' => 'const debounceAsync = (fn, ms) => { let t; return async (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };', 'description' => 'Debounce an async function.', 'purpose' => 'Limit async calls.' ],
        [ 'code' => 'const throttleAsync = (fn, ms) => { let last = 0; return async (...a) => { const now = Date.now(); if (now - last > ms) { last = now; await fn(...a); } }; };', 'description' => 'Throttle an async function.', 'purpose' => 'Limit async frequency.' ],
        [ 'code' => 'const sleep = ms => new Promise(res => setTimeout(res, ms));', 'description' => 'Sleep for ms milliseconds.', 'purpose' => 'Delay in async code.' ],
        [ 'code' => 'const isDeepEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);', 'description' => 'Check deep equality of two values.', 'purpose' => 'Deep comparison.' ],
        [ 'code' => 'const getEnv = key => process.env[key];', 'description' => 'Get an environment variable.', 'purpose' => 'Access environment.' ],
        [ 'code' => 'const parseCSV = str => str.split("\\n").map(row => row.split(","));', 'description' => 'Parse CSV string to array.', 'purpose' => 'CSV parsing.' ],
        [ 'code' => 'const toCSV = arr => arr.map(row => row.join(",")).join("\\n");', 'description' => 'Convert array to CSV string.', 'purpose' => 'CSV formatting.' ],
        [ 'code' => 'const proxy = new Proxy(target, { get: (target, prop) => target[prop] ?? "default" });', 'description' => 'Proxy for custom object access.', 'purpose' => 'Intercept object operations.' ],
        [ 'code' => 'const streamData = fs.createReadStream("file.txt").pipe(transform).pipe(process.stdout);', 'description' => 'Stream and transform file data.', 'purpose' => 'Efficient data processing.' ],
        [ 'code' => 'const tree = { value: 1, left: { value: 2 }, right: { value: 3 } };', 'description' => 'Tree data structure.', 'purpose' => 'Hierarchical data.' ],
        [ 'code' => 'const fibonacci = (n) => n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);', 'description' => 'Recursive Fibonacci function.', 'purpose' => 'Recursion example.' ],
        [ 'code' => 'const evaluate = (expr) => new Function("return " + expr)();', 'description' => 'Evaluate a string as code.', 'purpose' => 'Dynamic code execution.' ],
    ],
    'hard' => [
        // 1-100 (expanded hard examples)
        [ 'code' => 'const memoize = fn => { const cache = {}; return (...args) => cache[args] || (cache[args] = fn(...args)); };', 'description' => 'Memoize a function to cache results.', 'purpose' => 'Optimize repeated calculations.' ],
        [ 'code' => 'const deepClone = obj => JSON.parse(JSON.stringify(obj));', 'description' => 'Deep clone an object.', 'purpose' => 'Copy nested objects.' ],
        [ 'code' => 'const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);', 'description' => 'Compose multiple functions.', 'purpose' => 'Function composition.' ],
        [ 'code' => 'const debounce = (fn, delay) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => fn(...args), delay); }; };', 'description' => 'Debounce a function.', 'purpose' => 'Limit function calls.' ],
        [ 'code' => 'async function* asyncGenerator() { for (let i = 0; i < 5; i++) { yield new Promise(resolve => setTimeout(() => resolve(i), 100)); } }', 'description' => 'Async generator yielding promises.', 'purpose' => 'Produce async data streams.' ],
        [ 'code' => 'const proxy = new Proxy(target, { get: (target, prop) => target[prop] ?? "default" });', 'description' => 'Proxy for custom object access.', 'purpose' => 'Intercept object operations.' ],
        [ 'code' => 'const streamData = fs.createReadStream("file.txt").pipe(transform).pipe(process.stdout);', 'description' => 'Stream and transform file data.', 'purpose' => 'Efficient data processing.' ],
        [ 'code' => 'const tree = { value: 1, left: { value: 2 }, right: { value: 3 } };', 'description' => 'Tree data structure.', 'purpose' => 'Hierarchical data.' ],
        [ 'code' => 'const fibonacci = (n) => n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);', 'description' => 'Recursive Fibonacci function.', 'purpose' => 'Recursion example.' ],
        [ 'code' => 'const evaluate = (expr) => new Function("return " + expr)();', 'description' => 'Evaluate a string as code.', 'purpose' => 'Dynamic code execution.' ],
        // 11-100 (new hard examples)
        [ 'code' => 'const flattenDeep = arr => arr.reduce((a, v) => a.concat(Array.isArray(v) ? flattenDeep(v) : v), []);', 'description' => 'Recursively flatten an array.', 'purpose' => 'Deep array flattening.' ],
        [ 'code' => 'const quickSort = arr => arr.length < 2 ? arr : [...quickSort(arr.filter(x => x < arr[0])), arr[0], ...quickSort(arr.filter(x => x > arr[0]))];', 'description' => 'Quick sort implementation.', 'purpose' => 'Sorting algorithm.' ],
        [ 'code' => 'const curry = fn => (...a) => a.length >= fn.length ? fn(...a) : (...b) => curry(fn)(...a, ...b);', 'description' => 'Curry a function.', 'purpose' => 'Partial application.' ],
        [ 'code' => 'const throttle = (fn, ms) => { let last = 0; return (...a) => { const now = Date.now(); if (now - last > ms) { last = now; fn(...a); } }; };', 'description' => 'Throttle a function.', 'purpose' => 'Limit function frequency.' ],
        [ 'code' => 'const deepFreeze = obj => { Object.getOwnPropertyNames(obj).forEach(prop => { if (typeof obj[prop] === "object" && obj[prop] !== null) deepFreeze(obj[prop]); }); return Object.freeze(obj); };', 'description' => 'Recursively freeze an object.', 'purpose' => 'Immutable objects.' ],
        // End of hard examples
    ],
];


// Validate difficulty and fallback
if (!isset($codeSnippets[$difficulty]) || !is_array($codeSnippets[$difficulty]) || count($codeSnippets[$difficulty]) === 0) {
    // fallback order: medium -> easy -> hard -> first available
    if (isset($codeSnippets['medium']) && count($codeSnippets['medium']) > 0) {
        $difficulty = 'medium';
    } elseif (isset($codeSnippets['easy']) && count($codeSnippets['easy']) > 0) {
        $difficulty = 'easy';
    } elseif (isset($codeSnippets['hard']) && count($codeSnippets['hard']) > 0) {
        $difficulty = 'hard';
    } else {
        // fallback to first available
        $keys = array_keys($codeSnippets);
        $difficulty = $keys[0];
    }
}

// Build a unified pool of all snippets so we can pick by level (easy->hard)
$allSnippets = [];
foreach ($codeSnippets as $group) {
    if (is_array($group)) $allSnippets = array_merge($allSnippets, $group);
}

if (!is_array($allSnippets) || count($allSnippets) === 0) {
    echo json_encode([
        'success' => false,
        'error' => 'No code snippets available.'
    ]);
    exit();
}

// Normalize level as integer
$level = intval($level);

// Choose candidates by code length to approximate easy/medium/hard grouping
// short code = easy, medium length = medium, long = hard
$candidates = [];
foreach ($allSnippets as $s) {
    $len = isset($s['code']) ? strlen($s['code']) : 0;
    if ($level <= 3) {
        // Easy: short snippets
        if ($len <= 40) $candidates[] = $s;
    } elseif ($level <= 6) {
        // Medium: moderate length
        if ($len > 40 && $len <= 120) $candidates[] = $s;
    } else {
        // Hard: longer/complex snippets
        if ($len > 120) $candidates[] = $s;
    }
}

// If no candidates matched the heuristic, fallback to the full requested-difficulty list
if (count($candidates) === 0) {
    $snippets = isset($codeSnippets[$difficulty]) && is_array($codeSnippets[$difficulty]) ? $codeSnippets[$difficulty] : $allSnippets;
    $candidates = $snippets;
}

// Select a random snippet (or combine for higher levels)
$finalCode = '';
$description = '';
$purpose = '';

if ($level > 5 && count($candidates) > 1) {
    // Combine 2 snippets for higher levels to increase complexity
    $numToCombine = min(2, count($candidates));
    $combinedSnippets = [];
    $combinedDescriptions = [];
    $combinedPurposes = [];
    $usedIndexes = [];
    while (count($combinedSnippets) < $numToCombine) {
        $idx = array_rand($candidates);
        if (!in_array($idx, $usedIndexes)) {
            $usedIndexes[] = $idx;
            $combinedSnippets[] = $candidates[$idx]['code'];
            $combinedDescriptions[] = $candidates[$idx]['description'];
            $combinedPurposes[] = $candidates[$idx]['purpose'];
        }
    }
    $finalCode = implode("\n", $combinedSnippets);
    $description = implode("\n\n", $combinedDescriptions);
    $purpose = implode("\n\n", $combinedPurposes);
} else {
    $randomSnippet = $candidates[array_rand($candidates)];
    $finalCode = $randomSnippet['code'];
    $description = $randomSnippet['description'];
    $purpose = $randomSnippet['purpose'];
}

echo json_encode([
    'success' => true,
    'code' => $finalCode,
    'description' => $description,
    'purpose' => $purpose,
    'level' => $level,
    'difficulty' => $difficulty
]);
?>
